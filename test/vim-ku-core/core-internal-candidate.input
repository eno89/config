" Test: vim-ku-core core-internal-candidate
runtime! plugin/ku.vim plugin/ku/**/*.vim
call vspec#hint({'scope': 'ku#_local_variables()', 'sid': 'ku#_sid_prefix()'})
function s:describe__ku_omnifunc__findstart_0()  "{{{1
  It should return [] with no source

  call ku#start()
  Should nr2char(getchar(0)) ==# 'A'
  Should nr2char(getchar(0)) ==# ''

  Should ku#omnifunc(0, 'pattern') ==# []

  close

  It should return some candidate with a source

  let source = {}
  let source.name = 'test'
  function! source.gather_candidates(args)
    return [{'word': a:args.pattern, 'abbr': a:args.pattern[:2-1]}]
  endfunction
  Should ku#define_source(source) == 1

  call ku#start()
  Should nr2char(getchar(0)) ==# 'A'
  Should nr2char(getchar(0)) ==# ''

  Should ku#omnifunc(0, 'pattern') ==# [
  \ {'word': 'pattern',
  \  'abbr': 'pa',
  \  'menu': Ref('s:available_sources')['test'].name,
  \  'ku__source': Ref('s:available_sources')['test'],
  \  'dup': !0},
  \ ]
  Should ku#omnifunc(0, 'pattern') ==# Ref('s:session').last_lcandidates

  close

  It should return some candidate with a source and a:base contains a prompt

  call ku#start()
  Should nr2char(getchar(0)) ==# 'A'
  Should nr2char(getchar(0)) ==# ''

  Should ku#omnifunc(0, Ref('s:PROMPT').'pattern') ==# [
  \ {'word': 'pattern',
  \  'abbr': 'pa',
  \  'menu': Ref('s:available_sources')['test'].name,
  \  'ku__source': Ref('s:available_sources')['test'],
  \  'dup': !0},
  \ ]
  Should ku#omnifunc(0, 'pattern') ==# Ref('s:session').last_lcandidates

  close

  It requires to reset side effect

  Should ku#start() == 1
  Should nr2char(getchar(0)) ==# 'A'
  Should nr2char(getchar(0)) ==# ''
  bwipeout!

  ResetContext
endfunction




function s:describe__ku_omnifunc__findstart_1()  "{{{1
  It requires the following initialization

  call ku#start()
  Should nr2char(getchar(0)) ==# 'A'
  Should nr2char(getchar(0)) ==# ''

  It should succeed with the default state (there is only the prompt)

  " ku#start() has reset the content of the ku buffer.
  " So that the prompt must be in the ku buffer.
  Should ku#omnifunc(1, '') == 0
  Should Ref('s:session').last_lcandidates ==# []

  It should succeed with the prompt and some characters

  normal! Amane
  Should ku#omnifunc(1, '') == 0
  Should Ref('s:session').last_lcandidates ==# []

  It should succeed with no character

  normal! 0d$
  Should ku#omnifunc(1, '') == 0
  Should Ref('s:session').last_lcandidates ==# []

  It should succeed with some characters but no prompt

  normal! Amane
  Should ku#omnifunc(1, '') == 0
  Should Ref('s:session').last_lcandidates ==# []

  close

  It requires to reset side effect

  Should ku#start() == 1
  Should nr2char(getchar(0)) ==# 'A'
  Should nr2char(getchar(0)) ==# ''
  bwipeout!

  ResetContext
endfunction




function s:describe__s_cache_key()  "{{{1
  It should return a mangled version of a given pattern

  Should Call('s:cache_key', '') ==# '#'
  Should Call('s:cache_key', '#') ==# '##'
  Should Call('s:cache_key', 'abc') ==# '#abc'
  Should Call('s:cache_key', '%*(!)%*') ==# '#%*(!)%*'
endfunction




function s:describe__s_cache_lcandidates()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_c',
  \   'gather_candidates': function('function'),
  \   'cache_type': Ref('s:CACHE_CONSTANT'),
  \ }) != 0
  let source_c = ku#available_sources()['source_c']

  Should ku#define_source({
  \   'name': 'source_v',
  \   'gather_candidates': function('function'),
  \   'cache_type': Ref('s:CACHE_VOLATILE'),
  \ }) != 0
  let source_v = ku#available_sources()['source_v']

  call Set('s:session', Call('s:new_session', [source_c.name, source_v.name]))
  let session = Ref('s:session')
  Should session.cached_lcandidates ==# {}

  let lcandidates_c1 = [{'word': 'c1'}]
  let lcandidates_c2 = [{'word': 'c2'}]

  It should cache a given lcandidates for non-volatile sources

  let args = {'pattern': 'c1', 'source': source_c}
  call Call('s:cache_lcandidates', session, lcandidates_c1, args)
  let args = {'pattern': 'c2', 'source': source_c}
  call Call('s:cache_lcandidates', session, lcandidates_c2, args)

  Should session.cached_lcandidates ==# {
  \   source_c.name: {
  \     Call('s:cache_key', 'c1'): lcandidates_c1,
  \     Call('s:cache_key', 'c2'): lcandidates_c2,
  \   },
  \ }

  It should not cache a given lcandidates for volatile sources

  let args = {'pattern': 'v1', 'source': source_v}
  call Call('s:cache_lcandidates', session, [{'word': 'v1'}], args)
  let args = {'pattern': 'v2', 'source': source_v}
  call Call('s:cache_lcandidates', session, [{'word': 'v2'}], args)

  Should session.cached_lcandidates ==# {
  \   source_c.name: {
  \     Call('s:cache_key', 'c1'): lcandidates_c1,
  \     Call('s:cache_key', 'c2'): lcandidates_c2,
  \   },
  \ }

  It should cache lcandidates for later use

  let args = {'source': source_c, 'pattern': 'c1'}
  Should Call('s:get_cached_lcandidates', session, args) is lcandidates_c1
  let args = {'source': source_c, 'pattern': 'c2'}
  Should Call('s:get_cached_lcandidates', session, args) is lcandidates_c2

  let args = {'source': source_v, 'pattern': 'v1'}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')
  let args = {'source': source_v, 'pattern': 'v2'}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')

  It requires to reset side effect

  ResetContext
  Should ku#available_source_p('source_c') == 0
  Should ku#available_source_p('source_v') == 0
endfunction




function s:describe__s_filter_lcandidates()  "{{{1
  function! Test_filter_odd(lcandidates, args)
    return filter(a:lcandidates, 'len(v:val.word) % 2')
  endfunction

  function! Test_filter_m(lcandidates, args)
    return filter(a:lcandidates, 'v:val.word =~# "m"')
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'a'},
  \     {'word': 'lm'},
  \     {'word': 'bcd'},
  \     {'word': 'uvwx'},
  \     {'word': 'mnopq'},
  \   ]
  let ARGS = {
  \     'pattern': '',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_EMPTY = {
  \     'filters': [],
  \   }
  let SOURCE_M = {
  \     'filters': [function('Test_filter_m')],
  \   }
  let SOURCE_M_ODD = {
  \     'filters': [function('Test_filter_m'),
  \                 function('Test_filter_odd')],
  \   }
  let SOURCE_ODD = {
  \     'filters': [function('Test_filter_odd')],
  \   }
  let SOURCE_ODD_M = {
  \     'filters': [function('Test_filter_odd'),
  \                 function('Test_filter_m')],
  \   }

  It should return candidates as-is with no filter

  Should Call('s:filter_lcandidates', copy(RAW_LCANDIDATES), ARGS,SOURCE_EMPTY)
  \ ==# [
  \ {'word': 'a'},
  \ {'word': 'lm'},
  \ {'word': 'bcd'},
  \ {'word': 'uvwx'},
  \ {'word': 'mnopq'},
  \ ]

  It should return candidates filtered by M

  Should Call('s:filter_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M)
  \ ==# [
  \ {'word': 'lm'},
  \ {'word': 'mnopq'},
  \ ]

  It should return candidates filtered by ODD

  Should Call('s:filter_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD)
  \ ==# [
  \ {'word': 'a'},
  \ {'word': 'bcd'},
  \ {'word': 'mnopq'},
  \ ]

  It should return candidates filtered by M and ODD

  Should Call('s:filter_lcandidates', copy(RAW_LCANDIDATES), ARGS,SOURCE_M_ODD)
  \ ==# [
  \ {'word': 'mnopq'},
  \ ]

  It should return the same candidates regardless of order of filters

  Should Call('s:filter_lcandidates', copy(RAW_LCANDIDATES), ARGS,SOURCE_ODD_M)
  \ ==# Call('s:filter_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M_ODD)

  ResetContext
endfunction




function s:describe__s_get_cached_lcandidates()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'cache_type': Ref('s:CACHE_CONSTANT'),
  \ }) != 0
  let source_a = ku#available_sources()['source_a']

  call Set('s:session', Call('s:new_session', [source_a.name]))
  let session = Ref('s:session')
  Should session.cached_lcandidates ==# {}

  It should return s:NO_CACHE if there is no cached lcandidates

  let args = {'source': source_a, 'pattern': ''}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')
  let args = {'source': source_a, 'pattern': 'a'}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')

  Should session.cached_lcandidates ==# {'source_a': {}}

  It should return a cached one if there is a cached lcandidates

  let lcandidates_1 = [{'word': '#'}]
  let lcandidates_2 = [{'word': '#a'}]
  let lcandidates_3 = [{'word': 'a'}]
  let session.cached_lcandidates = {source_a.name: {
  \   Call('s:cache_key', ''): lcandidates_1,
  \   Call('s:cache_key', 'a'): lcandidates_2,
  \   'a': lcandidates_3,
  \ }}

  let args = {'source': source_a, 'pattern': ''}
  Should Call('s:get_cached_lcandidates', session, args) is lcandidates_1
  let args = {'source': source_a, 'pattern': 'a'}
  Should Call('s:get_cached_lcandidates', session, args) is lcandidates_2

  Should session.cached_lcandidates ==# {
  \   'source_a': {
  \     Call('s:cache_key', ''): lcandidates_1,
  \     Call('s:cache_key', 'a'): lcandidates_2,
  \     'a': lcandidates_3,
  \   },
  \ }

  It should always return s:NO_CACHE for s:CACHE_VOLATILE

  let source_a.cache_type = Ref('s:CACHE_VOLATILE')

  let args = {'source': source_a, 'pattern': ''}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')
  let args = {'source': source_a, 'pattern': 'a'}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')

  Should session.cached_lcandidates ==# {
  \   'source_a': {
  \     Call('s:cache_key', ''): lcandidates_1,
  \     Call('s:cache_key', 'a'): lcandidates_2,
  \     'a': lcandidates_3,
  \   },
  \ }

  It should return different values for different sources

  let source_a.cache_type = Ref('s:CACHE_CONSTANT')
  let source_a.name = 'source_A'

  let args = {'source': source_a, 'pattern': ''}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')
  let args = {'source': source_a, 'pattern': 'a'}
  Should Call('s:get_cached_lcandidates', session, args) is Ref('s:NO_CACHE')

  Should session.cached_lcandidates ==# {
  \   'source_a': {
  \     Call('s:cache_key', ''): lcandidates_1,
  \     Call('s:cache_key', 'a'): lcandidates_2,
  \     'a': lcandidates_3,
  \   },
  \   'source_A': {
  \   },
  \ }

  It requires to reset side effect

  ResetContext
  Should ku#available_source_p('source_a') == 0
endfunction




function s:describe__s_kinds_from_candidate()  "{{{1
  It requires the following initialization

  let _ = ku#define_source({
  \   'gather_candidates': function('type'),
  \   'name': 'test',
  \ })
  Should _ != 0
  Should ku#available_source_p('test') != 0
  let source = ku#available_sources()['test']
  Should ku#available_kind_p('common') != 0
  let kind_common = ku#available_kinds()['common']
  Should ku#available_kind_p('source/test') != 0
  let kind_source_test = ku#available_kinds()['source/test']

  It should return kinds defined by a source

  Should Call('s:kinds_from_candidate', {'ku__source': source})
  \ ==# [kind_source_test, kind_common]

  It should return kinds defined by a candidate

  Should Call('s:kinds_from_candidate',
  \           {'ku__source': source, 'ku__kinds': ['common', 'source/test']})
  \ ==# [kind_common, kind_source_test]

  It requires to reset side effect

  ResetContext
  Should ku#available_source_p('test') == 0
endfunction




function s:describe__s_lcandidates_from_pattern()  "{{{1
  function! Test_matcher_always(...)
    return 1
  endfunction

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('Test_matcher_always')],
  \   'filters': [],
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    return [{'word': a:args.pattern}]
  endfunction

  Should ku#define_source({
  \   'name': 'source_b',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('Test_matcher_always')],
  \   'filters': [],
  \ }) != 0
  let source_b = ku#available_sources()['source_b']
  function! source_b.gather_candidates(args)
    return [{'word': 'b'}, {'word': 'B'}]
  endfunction

  Should ku#define_source({
  \   'name': 'source_c',
  \   'gather_candidates': function('function'),
  \   'sorters': [function('ku#sorter#simple#sort')],
  \   'matchers': [function('Test_matcher_always')],
  \   'filters': [],
  \ }) != 0
  let source_c = ku#available_sources()['source_c']
  function! source_c.gather_candidates(args)
    return [{'word': 'u'}, {'word': 'p'}]
  endfunction

  It should return [] with no source

  let session = Call('s:new_session', [])
  Should Call('s:lcandidates_from_pattern', '2330', session) ==# []

  It should return some candidates with a source

  let session = Call('s:new_session', ['source_a'])
  Should Call('s:lcandidates_from_pattern', '2330', session)
  \ ==# [
  \   {'dup': !0, 'ku__source': source_a, 'menu': 'source_a', 'word': '2330'},
  \ ]

  It should return some candidates with multiple sources

  let session = Call('s:new_session', ['source_a', 'source_b'])
  Should Call('s:lcandidates_from_pattern', '2330', session)
  \ ==# [
  \   {'dup': !0, 'ku__source': source_a, 'menu': 'source_a', 'word': '2330'},
  \   {'dup': !0, 'ku__source': source_b, 'menu': 'source_b', 'word': 'b'},
  \   {'dup': !0, 'ku__source': source_b, 'menu': 'source_b', 'word': 'B'},
  \ ]

  It should return some candidates with multiple sources - duplicate sources
  " (although this case is not a valid usage)

  let session = Call('s:new_session', ['source_a', 'source_b', 'source_a'])
  Should Call('s:lcandidates_from_pattern','2330', session)
  \ ==# [
  \   {'dup': !0, 'ku__source': source_a, 'menu': 'source_a', 'word': '2330'},
  \   {'dup': !0, 'ku__source': source_b, 'menu': 'source_b', 'word': 'b'},
  \   {'dup': !0, 'ku__source': source_b, 'menu': 'source_b', 'word': 'B'},
  \   {'dup': !0, 'ku__source': source_a, 'menu': 'source_a', 'word': '2330'},
  \ ]

  It should return sorted candidates for a source with sorters

  let session = Call('s:new_session', ['source_c'])
  Should Call('s:lcandidates_from_pattern', '2330', session)
  \ ==# [
  \   {'dup': !0, 'ku__source': source_c, 'menu': 'source_c', 'word': 'p'},
  \   {'dup': !0, 'ku__source': source_c, 'menu': 'source_c', 'word': 'u'},
  \ ]

  It should return partially sorted candidates for sources with/without sorters

  let session = Call('s:new_session', ['source_c', 'source_b'])
  Should Call('s:lcandidates_from_pattern', '2330', session)
  \ ==# [
  \   {'dup': !0, 'ku__source': source_c, 'menu': 'source_c', 'word': 'p'},
  \   {'dup': !0, 'ku__source': source_c, 'menu': 'source_c', 'word': 'u'},
  \   {'dup': !0, 'ku__source': source_b, 'menu': 'source_b', 'word': 'b'},
  \   {'dup': !0, 'ku__source': source_b, 'menu': 'source_b', 'word': 'B'},
  \ ]

  ResetContext
endfunction




function s:describe__s_lcandidates_from_pattern__args_source()  "{{{1
  It requires the following initialization

  function! Test_matcher_always(...)
    return 1
  endfunction

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('Test_matcher_always')],
  \   'filters': [],
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    return [{'word': a:args.source.name}]
  endfunction

  Should ku#define_source({
  \   'name': 'source_b',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('Test_matcher_always')],
  \   'filters': [],
  \ }) != 0
  let source_b = ku#available_sources()['source_b']
  function! source_b.gather_candidates(args)
    return [{'word': a:args.source.name}]
  endfunction

  It should pass a valid args.source

  let session = Call('s:new_session', ['source_a', 'source_b'])
  Should Call('s:lcandidates_from_pattern', 'juni', session)
  \ ==# [
  \   {'dup':!0, 'ku__source':source_a, 'menu':'source_a', 'word':'source_a'},
  \   {'dup':!0, 'ku__source':source_b, 'menu':'source_b', 'word':'source_b'},
  \ ]

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_lcandidates_from_pattern__cache_constant()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_CONSTANT')

  let session = Call('s:new_session', [source_a.name])
  let pattern_a = 'a'
  let pattern_ab = 'ab'
  let pattern_ab_c = 'ab_c'
  let candidate_a = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_a,
  \ }
  let candidate_ab = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_ab,
  \ }
  let candidate_ab_c = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_ab_c,
  \ }

  It should call source.gather_candidates only once

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_a, session)
  Should _ ==# [candidate_a]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab, session)
  Should _ ==# [candidate_ab]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab_c, session)
  Should _ ==# [candidate_ab_c]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_a, session)
  Should _ ==# [candidate_a]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab, session)
  Should _ ==# [candidate_ab]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab_c, session)
  Should _ ==# [candidate_ab_c]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_lcandidates_from_pattern__cache_gel()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \   'special_chars': '_',
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_GEL')

  let session = Call('s:new_session', [source_a.name])
  let pattern_a = 'a'
  let pattern_ab = 'ab'
  let pattern_ab_c = 'ab_c'
  let candidate_a = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_a,
  \ }
  let candidate_ab = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_ab,
  \ }
  let candidate_ab_c = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_ab_c,
  \ }

  It should call source.gather_candidates by "special characters" in pattern

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_a, session)
  Should _ ==# [candidate_a]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab, session)
  Should _ ==# [candidate_ab]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_a, session)
  Should _ ==# [candidate_a]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab, session)
  Should _ ==# [candidate_ab]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab_c, session)
  Should _ ==# [candidate_ab_c]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_a, session)
  Should _ ==# [candidate_a]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab, session)
  Should _ ==# [candidate_ab]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_ab_c, session)
  Should _ ==# [candidate_ab_c]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_lcandidates_from_pattern__cache_invalid()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = '$*(!)*$%'

  let session = Call('s:new_session', [source_a.name])
  let pattern_x = 'x'
  let candidate_x = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_x,
  \ }

  It should raise error but behave as if "pattern"

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_x, session)
  Should _ ==# [candidate_x]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg =~# '^ku:e3:'

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_x, session)
  Should _ ==# [candidate_x]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg == ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_lcandidates_from_pattern__cache_pattern()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_PATTERN')

  let session = Call('s:new_session', [source_a.name])
  let pattern_g = 'g'
  let pattern_G = 'G'
  let candidate_g = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_g,
  \ }
  let candidate_G = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_G,
  \ }

  It should call source.gather_candidates for different pattern

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_g, session)
  Should _ ==# [candidate_g]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_G, session)
  Should _ ==# [candidate_G]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_g, session)
  Should _ ==# [candidate_g]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_G, session)
  Should _ ==# [candidate_G]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_lcandidates_from_pattern__cache_volatile()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_VOLATILE')

  let session = Call('s:new_session', [source_a.name])
  let pattern_x = 'x'
  let candidate_x = {
  \   'dup': !0,
  \   'ku__source': source_a,
  \   'menu': source_a.name,
  \   'word': pattern_x,
  \ }

  It should call source.gather_candidates for each time

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_x, session)
  Should _ ==# [candidate_x]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:lcandidates_from_pattern', pattern_x, session)
  Should _ ==# [candidate_x]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_make_lcandidates_for_a_source()  "{{{1
  It requires the following initialization

  function! Test_matcher_pattern_included_p(candidate, args)
    return 0 <= stridx(a:candidate.word, a:args.pattern)
  endfunction

  function! Test_filter_pattern_length(lcandidate, args)
    return filter(a:lcandidate, 'len(v:val.word) % 2 == 0')
  endfunction

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [function('ku#sorter#simple#sort')],
  \   'matchers': [function('Test_matcher_pattern_included_p')],
  \   'filters': [function('Test_filter_pattern_length')],
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    return [
    \   {'word': 'dcba'},
    \   {'word': 'a'},
    \   {'word': 'abc'},
    \   {'word': 'bc'},
    \   {'word': 'abcd'},
    \ ]
  endfunction

  It should return matched/filtered/sorted/normalized candidates

  let args = {'pattern': 'a', 'source': source_a}
  Should Call('s:make_lcandidates_for_a_source', args)
  \ ==# [
  \   {'dup': !0, 'ku__source': source_a, 'menu': 'source_a', 'word': 'abcd'},
  \   {'dup': !0, 'ku__source': source_a, 'menu': 'source_a', 'word': 'dcba'},
  \ ]

  It requires to reset side effect

  ResetContext
  Should has_key(ku#available_sources(), 'source_a') == 0
endfunction




function s:describe__s_matched_lcandidates()  "{{{1
  It requires the following initialization

  function! Test_matcher_odd(candidate, args)
    return len(a:candidate.word) % 2
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'mk'},
  \     {'word': 'iue'},
  \     {'word': 'kr'},
  \     {'word': 'oom'},
  \     {'word': 'tk'},
  \     {'word': 'oo'},
  \   ]
  let ARGS = {
  \     'pattern': 'm',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_S_O = {
  \     'matchers': [function('ku#matcher#simple#matches_p'),
  \                  function('Test_matcher_odd')],
  \   }
  let SOURCE_SIMPLE = {
  \     'matchers': [function('ku#matcher#simple#matches_p')],
  \   }
  let SOURCE_EMPTY = {
  \     'matchers': [],
  \   }
  let SOURCE_ODD = {
  \     'matchers': [function('Test_matcher_odd')],
  \   }

  It should return nothing with no matcher

  Should Call('s:matched_lcandidates', copy(RAW_LCANDIDATES),ARGS,SOURCE_EMPTY)
  \ ==# [
  \ ]

  It should return some candidates with the simple matcher

  Should Call('s:matched_lcandidates',
  \           copy(RAW_LCANDIDATES), ARGS, SOURCE_SIMPLE)
  \ ==# [
  \ {'word': 'mk'},
  \ {'word': 'oom'},
  \ ]

  It should return some candidates with a custom matcher

  Should Call('s:matched_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD)
  \ ==# [
  \ {'word': 'iue'},
  \ {'word': 'oom'},
  \ ]

  It should return some candidates matched with "simple" or "odd"

  Should Call('s:matched_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_S_O)
  \ ==# [
  \ {'word': 'mk'},
  \ {'word': 'oom'},
  \ {'word': 'iue'},
  \ {'word': 'oom'},
  \ ]

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_normalize_candidate()  "{{{1
  It should normalize a given candidate with a given source

  let candidate = {'word': 'smooooch'}
  let dummy_source = {'name': 'CANDY RAVE'}
  Should Call('s:normalize_candidate', candidate, dummy_source) is candidate
  Should candidate ==# {
  \   'ku__source': dummy_source,
  \   'menu': dummy_source.name,
  \   'word': 'smooooch',
  \   'dup': !0,
  \ }
endfunction




function s:describe__s_raw_lcandidates()  "{{{1
  It requires the following initialization

  let _ = ku#define_source({
  \   'name': 'test',
  \   'gather_candidates': function('function'),
  \ })
  Should _ != 0
  let source = ku#available_sources()['test']
  function! source.gather_candidates(args)
    return [
    \   {'word': 'a'},
    \   {'word': 'l'},
    \   {'word': 't'},
    \   {'word': 'e'},
    \   {'word': 'r'},
    \ ]
  endfunction

  It should return raw candidates gatherd by a given source

  Should Call('s:raw_lcandidates', {'pattern': '!', 'source': source}) == [
  \   {'word': 'a'},
  \   {'word': 'l'},
  \   {'word': 't'},
  \   {'word': 'e'},
  \   {'word': 'r'},
  \ ]

  It requires to reset side effect

  ResetContext
  Should has_key(ku#available_sources(), 'test') == 0
endfunction




function s:describe__s_raw_lcandidates__cache_constant()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_CONSTANT')

  let args_a = {'pattern': 'a', 'source': source_a}
  let args_ab = {'pattern': 'ab', 'source': source_a}
  let args_ab_c = {'pattern': 'ab_c', 'source': source_a}

  It should call source.gather_candidates only once

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_a)
  Should _ ==# [{'word': 'a'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab)
  Should _ ==# [{'word': 'ab'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab_c)
  Should _ ==# [{'word': 'ab_c'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_a)
  Should _ ==# [{'word': 'a'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 4
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab)
  Should _ ==# [{'word': 'ab'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 5
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab_c)
  Should _ ==# [{'word': 'ab_c'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 6
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_raw_lcandidates__cache_gel()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \   'special_chars': '_',
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_GEL')

  let args_a = {'pattern': 'a', 'source': source_a}
  let args_ab = {'pattern': 'ab', 'source': source_a}
  let args_ab_c = {'pattern': 'ab_c', 'source': source_a}

  It should call source.gather_candidates by "special characters" in pattern

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_a)
  Should _ ==# [{'word': 'a'}]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab)
  Should _ ==# [{'word': 'ab'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_a)
  Should _ ==# [{'word': 'a'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab)
  Should _ ==# [{'word': 'ab'}]
    " FIXME: NIY - This should be 1.
  Should source_a.ku__source_a__count == 4
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab_c)
  Should _ ==# [{'word': 'ab_c'}]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 5
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_a)
  Should _ ==# [{'word': 'a'}]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 6
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab)
  Should _ ==# [{'word': 'ab'}]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 7
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_ab_c)
  Should _ ==# [{'word': 'ab_c'}]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 8
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_raw_lcandidates__cache_invalid()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = '$*(!)*$%'

  let args = {'pattern': 'x', 'source': source_a}

  It should raise error but behave as if "volatile"

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args)
  Should _ ==# [{'word': 'x'}]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg =~# '^ku:e3:'

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args)
  Should _ ==# [{'word': 'x'}]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg =~# '^ku:e3:'

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_raw_lcandidates__cache_pattern()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_PATTERN')

  let args_g = {'pattern': 'g', 'source': source_a}
  let args_G = {'pattern': 'G', 'source': source_a}

  It should call source.gather_candidates for different pattern

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_g)
  Should _ ==# [{'word': 'g'}]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_G)
  Should _ ==# [{'word': 'G'}]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_g)
  Should _ ==# [{'word': 'g'}]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 3
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args_G)
  Should _ ==# [{'word': 'G'}]
    " FIXME: NIY - This should be 2.
  Should source_a.ku__source_a__count == 4
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_raw_lcandidates__cache_volatile()  "{{{1
  It requires the following initialization

  Should ku#define_source({
  \   'name': 'source_a',
  \   'gather_candidates': function('function'),
  \   'sorters': [],
  \   'matchers': [function('ku#matcher#true#matches_p')],
  \   'filters': [],
  \   'ku__source_a__count': 0,
  \ }) != 0
  let source_a = ku#available_sources()['source_a']
  function! source_a.gather_candidates(args)
    let a:args.source.ku__source_a__count += 1
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.cache_type = Ref('s:CACHE_VOLATILE')

  let args = {'pattern': 'x', 'source': source_a}

  It should call source.gather_candidates for each time

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args)
  Should _ ==# [{'word': 'x'}]
  Should source_a.ku__source_a__count == 1
  Should v:errmsg ==# ''

  let v:errmsg = ''
  silent! let _ = Call('s:raw_lcandidates', args)
  Should _ ==# [{'word': 'x'}]
  Should source_a.ku__source_a__count == 2
  Should v:errmsg ==# ''

  It requires to reset side effect

  ResetContext
endfunction




function s:describe__s_sort_lcandidates()  "{{{1
  function! Test_sorter_reverse(lcandidates, args)
    return reverse(a:lcandidates)
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'a'},
  \     {'word': 'l'},
  \     {'word': 'b'},
  \     {'word': 'u'},
  \     {'word': 'm'},
  \   ]
  let ARGS = {
  \     'pattern': '',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_EMPTY = {
  \     'sorters': [],
  \   }
  let SOURCE_REVERSE = {
  \     'sorters': [function('Test_sorter_reverse')],
  \   }
  let SOURCE_S_R = {
  \     'sorters': [function('ku#sorter#simple#sort'),
  \                 function('Test_sorter_reverse')],
  \   }
  let SOURCE_SIMPLE = {
  \     'sorters': [function('ku#sorter#simple#sort')],
  \   }

  It should return unsorted candidates with no sorter

  Should Call('s:sort_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_EMPTY)
  \ ==# [
  \ {'word': 'a'},
  \ {'word': 'l'},
  \ {'word': 'b'},
  \ {'word': 'u'},
  \ {'word': 'm'},
  \ ]

  It should return sorted candidates with a sorter

  Should Call('s:sort_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_SIMPLE)
  \ ==# [
  \ {'word': 'a'},
  \ {'word': 'b'},
  \ {'word': 'l'},
  \ {'word': 'm'},
  \ {'word': 'u'},
  \ ]

  It should return sorted candidates with a custom sorter

  Should Call('s:sort_lcandidates', copy(RAW_LCANDIDATES), ARGS,SOURCE_REVERSE)
  \ ==# [
  \ {'word': 'm'},
  \ {'word': 'u'},
  \ {'word': 'b'},
  \ {'word': 'l'},
  \ {'word': 'a'},
  \ ]

  It should return candidates sorted by "simple" then sorted by "reverse"

  Should Call('s:sort_lcandidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_S_R)
  \ ==# [
  \ {'word': 'u'},
  \ {'word': 'm'},
  \ {'word': 'l'},
  \ {'word': 'b'},
  \ {'word': 'a'},
  \ ]

  ResetContext
endfunction




" __END__  "{{{1
" vim: filetype=vim foldmethod=marker
