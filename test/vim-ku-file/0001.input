" Tests for misc. utilities
" Set up  "{{{1

let s:SID_PREFIX = ku#file#_sid_prefix()
function Call(function_name, ...)
  return call(substitute(a:function_name, '^s:', s:SID_PREFIX, ''), a:000)
endfunction

function! s:rm(path)
  " FIXME: This is not portable.
  "        But there is no function to delete a directory in Vim script.
  execute '!rm -fr' shellescape(a:path)
endfunction


let g:ku_personal_runtime = split(&runtimepath, ',')[0]


let s:expected_action_table = {
\     'default': 'ku#file#action_open',
\     'extract-asis': 'ku#file#action_extract_asis',
\     'extract-smartly': 'ku#file#action_extract_smartly',
\     'extract-solely': 'ku#file#action_extract_solely',
\     'open!': 'ku#file#action_open_x',
\     'open': 'ku#file#action_open',
\   }
let s:expected_key_table = {
\     "\<C-e>": 'extract-smartly',
\     "\<C-o>": 'open',
\     "\<Esc>e": 'extract-solely',
\     "\<M-e>": 'extract-solely',
\     'E': 'extract-asis',
\     'O': 'open!',
\     'e': 'extract-smartly',
\     'o': 'open',
\   }


cd `=ku#make_path('test', 'vim-ku-file', 'test-data')`




function s:test_archive_basename_0001()  "{{{1
  Title let _ = Call('s:archive_basename', 'foo.bar')  " Unknown case.
  Assert _ ==> 'foo.bar'
endfunction




function s:test_archive_basename_0002()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.zip')
  Assert _ ==> 'a'
endfunction




function s:test_archive_basename_0003()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.ZiP')  " FIXME: How about cases?
  Assert _ ==> 'a.ZiP'
endfunction




function s:test_archive_basename_0004()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.Z')  " Not supported yet
  Assert _ ==> 'a.Z'
endfunction




function s:test_archive_basename_0005()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.bz2')  " Not supported yet
  Assert _ ==> 'a.bz2'
endfunction




function s:test_archive_basename_0006()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.gz')  " Not supported yet
  Assert _ ==> 'a.gz'
endfunction




function s:test_archive_basename_0007()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.tar')  " Not supported yet
  Assert _ ==> 'a.tar'
endfunction




function s:test_archive_basename_0008()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.tar.Z')  " Not supported yet
  Assert _ ==> 'a.tar.Z'
endfunction




function s:test_archive_basename_0009()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.tar.bz2')  " Not supported yet
  Assert _ ==> 'a.tar.bz2'
endfunction




function s:test_archive_basename_0010()  "{{{1
  Title let _ = Call('s:archive_basename', 'a.tar.gz')  " Not supported yet
  Assert _ ==> 'a.tar.gz'
endfunction




function s:test_archive_type_0001()  "{{{1
  Title let _ = Call('s:archive_type', ku#make_path('a.zip'))
  Assert type(_) ==> type('')
  Assert _ ==> ku#file#_local_variables().ARCHIVE_TYPE_ZIP
endfunction




function s:test_archive_type_0002()  "{{{1
  Title let _ = Call('s:archive_type', ku#make_path('dir1.zip'))
  Assert type(_) ==> type('')
  Assert _ ==> ku#file#_local_variables().ARCHIVE_TYPE_INVALID
endfunction




function s:test_archive_type_0003()  "{{{1
  Title let _ = Call('s:archive_type', ku#make_path('dir1', 'file2'))
  Assert type(_) ==> type('')
  Assert _ ==> ku#file#_local_variables().ARCHIVE_TYPE_INVALID
endfunction




function s:test_archive_type_0004()  "{{{1
  Title let _ = Call('s:archive_type', ku#make_path('.', 'b.zip'))
  Assert type(_) ==> type('')
  Assert _ ==> ku#file#_local_variables().ARCHIVE_TYPE_ZIP
endfunction




function s:test_first_directory_0001()  "{{{1
  Title let _ = Call('s:first_directory', ku#make_path('foo'))
  Assert _ ==> ''
endfunction




function s:test_first_directory_0002()  "{{{1
  Title let _ = Call('s:first_directory', ku#make_path('foo', 'bar'))
  Assert _ ==> 'foo'
endfunction




function s:test_first_directory_0003()  "{{{1
  Title let _ = Call('s:first_directory', ku#make_path('foo', 'bar', 'baz'))
  Assert _ ==> 'foo'
endfunction




function s:test_first_directory_0004()  "{{{1
  Title let _ = Call('s:first_directory', ku#make_path('', 'foo'))
  Assert _ ==> ''
endfunction




function s:test_ku_file_acc_valid_p_0001()  "{{{1
  let file_item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#acc_valid_p('', file_item, ku#path_separator())
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0002()  "{{{1
  let directory_item = {'word': ku#make_path('dir1')}
  Title let _ = ku#file#acc_valid_p('', directory_item, ku#path_separator())
  Assert _ ==> 1
endfunction




function s:test_ku_file_acc_valid_p_0003()  "{{{1
  let file_item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#acc_valid_p('', file_item, 'a')  " Invalid sep.
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0004()  "{{{1
  let directory_item = {'word': ku#make_path('dir1')}
  Title let _ = ku#file#acc_valid_p('', directory_item, 'a')  " Invalid sep.
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0005()  "{{{1
  let file_item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#acc_valid_p('foo', file_item, ku#path_separator())
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0006()  "{{{1
  let directory_item = {'word': ku#make_path('dir1')}
  Title let _ = ku#file#acc_valid_p('foo', directory_item, ku#path_separator())
  Assert _ ==> 1
endfunction




function s:test_ku_file_acc_valid_p_0007()  "{{{1
  let file_item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#acc_valid_p('foo', file_item, 'a')  " Invalid sep.
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0008()  "{{{1
  let directory_item = {'word': ku#make_path('dir1')}
  Title let _ = ku#file#acc_valid_p('foo', directory_item, 'a')  " Invalid sep.
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0009()  "{{{1
  let archive_item = {'word': ku#make_path('a.zip')}
  Title let _ = ku#file#acc_valid_p('', archive_item, ku#path_separator())
  Assert _ ==> 1
endfunction




function s:test_ku_file_acc_valid_p_0010()  "{{{1
  let archive_item = {'word': ku#make_path('a.zip')}
  Title let _ = ku#file#acc_valid_p('', archive_item, 'a')
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0011()  "{{{1
  let archive_item = {'word': ku#make_path('a.zip', 'a', 'foo.txt')}
  Title let _ = ku#file#acc_valid_p('', archive_item, ku#path_separator())
  Assert _ ==> 0
endfunction




function s:test_ku_file_acc_valid_p_0012()  "{{{1
  let archive_item = {'word': ku#make_path('a.zip', 'a', 'foo.txt')}
  Title let _ = ku#file#acc_valid_p('', archive_item, 'a')
  Assert _ ==> 0
endfunction




function s:test_ku_file_action_extract_asis_0001()  "{{{1
  let item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type('')
  Assert _ ==>
  \ 'extract-asis: Not available for this item: ' . string(item.word)
endfunction




function s:test_ku_file_action_extract_asis_0002()  "{{{1
  let item = {'word': ku#make_path('a.zip')}
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('a')) ==> 1
  Assert filereadable(ku#make_path('a', 'foo.txt')) ==> 1
  Assert filereadable(ku#make_path('a', 'foofoo.txt')) ==> 1

  " Remove extracted files.
  call s:rm('a')
endfunction




function s:test_ku_file_action_extract_asis_0003()  "{{{1
  let item = {'word': ku#make_path('b.zip')}
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert filereadable(ku#make_path('bar.txt')) ==> 1
  Assert filereadable(ku#make_path('barbar.txt')) ==> 1

  " Remove extracted files.
  call s:rm('bar.txt')
  call s:rm('barbar.txt')
endfunction




function s:test_ku_file_action_extract_asis_0004()  "{{{1
  let item = {'word': ku#make_path('c.zip')}
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 1
  Assert isdirectory(ku#make_path('d')) ==> 1
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 1
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 1

  " Remove extracted files.
  call s:rm('c')
  call s:rm('d')
endfunction




function s:test_ku_file_action_extract_asis_0005()  "{{{1
  let item = {
  \   'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('a.zip'),
  \   'ku_file_archive_content_path': ku#make_path('a', 'foo.txt')
  \ }
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('a')) ==> 1
  Assert filereadable(ku#make_path('a', 'foo.txt')) ==> 1
  Assert filereadable(ku#make_path('a', 'foofoo.txt')) ==> 0

  " Remove extracted files.
  call s:rm('a')
endfunction




function s:test_ku_file_action_extract_asis_0006()  "{{{1
  let item = {
  \   'word': ku#make_path('b.zip', 'bar.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('b.zip'),
  \   'ku_file_archive_content_path': ku#make_path('bar.txt')
  \ }
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert filereadable(ku#make_path('bar.txt')) ==> 1
  Assert filereadable(ku#make_path('barbar.txt')) ==> 0

  " Remove extracted files.
  call s:rm('bar.txt')
  call s:rm('barbar.txt')
endfunction




function s:test_ku_file_action_extract_asis_0007()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'c', 'baz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('c', 'baz.txt')
  \ }
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 1
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 1
  Assert isdirectory(ku#make_path('d')) ==> 0
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 0

  " Remove extracted files.
  call s:rm('c')
  call s:rm('d')
endfunction




function s:test_ku_file_action_extract_asis_0008()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'd', 'bazbaz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('d', 'bazbaz.txt')
  \ }
  Title let _ = ku#file#action_extract_asis(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 0
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 0
  Assert isdirectory(ku#make_path('d')) ==> 1
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 1

  " Remove extracted files.
  call s:rm('c')
  call s:rm('d')
endfunction




function s:test_ku_file_action_extract_smartly_0001()  "{{{1
  let item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type('')
  Assert _ ==>
  \ 'extract-smartly: Not available for this item: ' . string(item.word)
endfunction




function s:test_ku_file_action_extract_smartly_0002()  "{{{1
  let item = {'word': ku#make_path('a.zip')}
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('a')) ==> 1
  Assert filereadable(ku#make_path('a', 'foo.txt')) ==> 1
  Assert filereadable(ku#make_path('a', 'foofoo.txt')) ==> 1
  Assert isdirectory(ku#make_path('a', 'a')) ==> 0

  " Remove extracted files.
  call s:rm('a')
endfunction




function s:test_ku_file_action_extract_smartly_0003()  "{{{1
  let item = {'word': ku#make_path('b.zip')}
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('b')) ==> 1
  Assert filereadable(ku#make_path('b', 'bar.txt')) ==> 1
  Assert filereadable(ku#make_path('b', 'barbar.txt')) ==> 1
  Assert filereadable(ku#make_path('bar.txt')) ==> 0
  Assert filereadable(ku#make_path('barbar.txt')) ==> 0

  " Remove extracted files.
  call s:rm('b')
  call s:rm('bar.txt')
  call s:rm('barbar.txt')
endfunction




function s:test_ku_file_action_extract_smartly_0004()  "{{{1
  let item = {'word': ku#make_path('c.zip')}
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 1
  Assert isdirectory(ku#make_path('c', 'c')) ==> 1
  Assert isdirectory(ku#make_path('c', 'd')) ==> 1
  Assert filereadable(ku#make_path('c', 'c', 'baz.txt')) ==> 1
  Assert filereadable(ku#make_path('c', 'd', 'bazbaz.txt')) ==> 1
  Assert isdirectory(ku#make_path('d')) ==> 0
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 0
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 0

  " Remove extracted files.
  call s:rm('c')
  call s:rm('d')
endfunction




function s:test_ku_file_action_extract_smartly_0005()  "{{{1
  let item = {
  \   'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('a.zip'),
  \   'ku_file_archive_content_path': ku#make_path('a', 'foo.txt')
  \ }
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('a')) ==> 1
  Assert filereadable(ku#make_path('a', 'foo.txt')) ==> 1
  Assert filereadable(ku#make_path('a', 'foofoo.txt')) ==> 0

  " Remove extracted files.
  call s:rm('a')
endfunction




function s:test_ku_file_action_extract_smartly_0006()  "{{{1
  let item = {
  \   'word': ku#make_path('b.zip', 'bar.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('b.zip'),
  \   'ku_file_archive_content_path': ku#make_path('bar.txt')
  \ }
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('b')) ==> 1
  Assert filereadable(ku#make_path('b', 'bar.txt')) ==> 1
  Assert filereadable(ku#make_path('b', 'barbar.txt')) ==> 0
  Assert filereadable(ku#make_path('bar.txt')) ==> 0
  Assert filereadable(ku#make_path('barbar.txt')) ==> 0

  " Remove extracted files.
  call s:rm('b')
endfunction




function s:test_ku_file_action_extract_smartly_0007()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'c', 'baz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('c', 'baz.txt')
  \ }
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 1
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 1
  Assert filereadable(ku#make_path('c', 'bazbaz.txt')) ==> 0
  Assert isdirectory(ku#make_path('d')) ==> 0
  Assert filereadable(ku#make_path('d', 'baz.txt')) ==> 0
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 0

  " Remove extracted files.
  call s:rm('c')
endfunction




function s:test_ku_file_action_extract_smartly_0008()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'd', 'bazbaz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('d', 'bazbaz.txt')
  \ }
  Title let _ = ku#file#action_extract_smartly(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 1
  Assert isdirectory(ku#make_path('c', 'd')) ==> 1
  Assert filereadable(ku#make_path('c', 'd', 'bazbaz.txt')) ==> 1
  Assert isdirectory(ku#make_path('d')) ==> 0

  " Remove extracted files.
  call s:rm('c')
endfunction




function s:test_ku_file_action_extract_solely_0001()  "{{{1
  let item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type('')
  Assert _ ==>
  \ 'extract-solely: Not available for this item: ' . string(item.word)
endfunction




function s:test_ku_file_action_extract_solely_0002()  "{{{1
  let item = {'word': ku#make_path('a.zip')}
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type('')
  Assert _ ==>
  \ 'extract-solely: Not available for this item: ' . string(item.word)
endfunction




function s:test_ku_file_action_extract_solely_0003()  "{{{1
  let item = {'word': ku#make_path('b.zip')}
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type('')
  Assert _ ==>
  \ 'extract-solely: Not available for this item: ' . string(item.word)
endfunction




function s:test_ku_file_action_extract_solely_0004()  "{{{1
  let item = {'word': ku#make_path('c.zip')}
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type('')
  Assert _ ==>
  \ 'extract-solely: Not available for this item: ' . string(item.word)
endfunction




function s:test_ku_file_action_extract_solely_0005()  "{{{1
  let item = {
  \   'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('a.zip'),
  \   'ku_file_archive_content_path': ku#make_path('a', 'foo.txt')
  \ }
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert filereadable(ku#make_path('foo.txt')) ==> 1
  Assert isdirectory(ku#make_path('a')) ==> 0
  Assert filereadable(ku#make_path('a', 'foo.txt')) ==> 0
  Assert filereadable(ku#make_path('a', 'foofoo.txt')) ==> 0

  " Remove extracted files.
  call s:rm('a')
  call s:rm('foo.txt')
  call s:rm('foofoo.txt')
endfunction




function s:test_ku_file_action_extract_solely_0006()  "{{{1
  let item = {
  \   'word': ku#make_path('b.zip', 'bar.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('b.zip'),
  \   'ku_file_archive_content_path': ku#make_path('bar.txt')
  \ }
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert filereadable(ku#make_path('bar.txt')) ==> 1
  Assert filereadable(ku#make_path('barbar.txt')) ==> 0

  " Remove extracted files.
  call s:rm('bar.txt')
  call s:rm('barbar.txt')
endfunction




function s:test_ku_file_action_extract_solely_0007()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'c', 'baz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('c', 'baz.txt')
  \ }
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert filereadable(ku#make_path('baz.txt')) ==> 1
  Assert filereadable(ku#make_path('bazbaz.txt')) ==> 0
  Assert isdirectory(ku#make_path('c')) ==> 0
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 0
  Assert isdirectory(ku#make_path('d')) ==> 0
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 0

  " Remove extracted files.
  call s:rm('baz.txt')
  call s:rm('bazbaz.txt')
  call s:rm('c')
  call s:rm('d')
endfunction




function s:test_ku_file_action_extract_solely_0008()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'd', 'bazbaz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('d', 'bazbaz.txt')
  \ }
  Title let _ = ku#file#action_extract_solely(item)
  Assert type(_) ==> type(0)
  Assert _ ==> 0
  Assert filereadable(ku#make_path('baz.txt')) ==> 0
  Assert filereadable(ku#make_path('bazbaz.txt')) ==> 1
  Assert isdirectory(ku#make_path('c')) ==> 0
  Assert filereadable(ku#make_path('c', 'baz.txt')) ==> 0
  Assert isdirectory(ku#make_path('d')) ==> 0
  Assert filereadable(ku#make_path('d', 'bazbaz.txt')) ==> 0

  " Remove extracted files.
  call s:rm('baz.txt')
  call s:rm('bazbaz.txt')
  call s:rm('c')
  call s:rm('d')
endfunction




function s:test_ku_file_action_open_0001()  "{{{1
  let item = {'word': ku#make_path('file1')}
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> 'file1'
  Assert line('$') ==> 1
  Assert getline(1) ==> ''
  enew!
endfunction




function s:test_ku_file_action_open_0002()  "{{{1
  let item = {'word': ku#make_path('a.zip')}
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> 'a.zip'
  Assert 2 < line('$') ==> 1
  Assert getline(line('$') - 1) ==> ku#make_path('a', 'foo.txt')
  Assert getline(line('$')) ==> ku#make_path('a', 'foofoo.txt')
  enew!
endfunction




function s:test_ku_file_action_open_0003()  "{{{1
  let item = {'word': ku#make_path('b.zip')}
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> 'b.zip'
  Assert 2 < line('$') ==> 1
  Assert getline(line('$') - 1) ==> ku#make_path('bar.txt')
  Assert getline(line('$')) ==> ku#make_path('barbar.txt')
  enew!
endfunction




function s:test_ku_file_action_open_0004()  "{{{1
  let item = {'word': ku#make_path('c.zip')}
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> 'c.zip'
  Assert 2 < line('$') ==> 1
  Assert getline(line('$') - 1) ==> ku#make_path('c', 'baz.txt')
  Assert getline(line('$')) ==> ku#make_path('d', 'bazbaz.txt')
  enew!
endfunction




function s:test_ku_file_action_open_0005()  "{{{1
  let item = {
  \   'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('a.zip'),
  \   'ku_file_archive_content_path': ku#make_path('a', 'foo.txt')
  \ }
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> printf('zipfile:%s::%s',
  \ fnamemodify(item.ku_file_archive_path, ':p'),
  \ item.ku_file_archive_content_path)
  Assert line('$') ==> 1
  Assert getline(1) ==> 'foo'
  enew!
endfunction




function s:test_ku_file_action_open_0006()  "{{{1
  let item = {
  \   'word': ku#make_path('b.zip', 'bar.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('b.zip'),
  \   'ku_file_archive_content_path': ku#make_path('bar.txt')
  \ }
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> printf('zipfile:%s::%s',
  \ fnamemodify(item.ku_file_archive_path, ':p'),
  \ item.ku_file_archive_content_path)
  Assert line('$') ==> 1
  Assert getline(1) ==> 'bar'
  enew!
endfunction




function s:test_ku_file_action_open_0007()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'c', 'baz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('c', 'baz.txt')
  \ }
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> printf('zipfile:%s::%s',
  \ fnamemodify(item.ku_file_archive_path, ':p'),
  \ item.ku_file_archive_content_path)
  Assert line('$') ==> 1
  Assert getline(1) ==> 'baz'
  enew!
endfunction




function s:test_ku_file_action_open_0008()  "{{{1
  let item = {
  \   'word': ku#make_path('c.zip', 'd', 'bazbaz.txt'),
  \   'ku_file_archive_format': ku#file#_local_variables().ARCHIVE_TYPE_ZIP,
  \   'ku_file_archive_path': ku#make_path('c.zip'),
  \   'ku_file_archive_content_path': ku#make_path('d', 'bazbaz.txt')
  \ }
  Title let _ = ku#file#action_open(item)
  Assert _ ==> 0
  Assert expand('%') ==> printf('zipfile:%s::%s',
  \ fnamemodify(item.ku_file_archive_path, ':p'),
  \ item.ku_file_archive_content_path)
  Assert line('$') ==> 1
  Assert getline(1) ==> 'bazbaz'
  enew!
endfunction




function s:test_ku_file_action_table_0001()  "{{{1
  let expected_action_table = s:expected_action_table
  Title let _ = ku#file#action_table('')
  Assert type(_) ==> type({})
  Assert _ ==> expected_action_table
endfunction




function s:test_ku_file_action_table_0002()  "{{{1
  let expected_action_table = s:expected_action_table
  Title let _ = ku#file#action_table('xyzzy')  " {ext} is not used.
  Assert type(_) ==> type({})
  Assert _ ==> expected_action_table
endfunction




function s:test_ku_file_available_sources_0001()  "{{{1
  Title let _ = ku#file#available_sources()
  Assert type(_) ==> type([])
  Assert _ ==> ['file']
endfunction




function s:test_ku_file_key_table_0001()  "{{{1
  let expected_key_table = s:expected_key_table
  Title let _ = ku#file#key_table('')
  Assert type(_) ==> type({})
  Assert _ ==> expected_key_table
endfunction




function s:test_ku_file_key_table_0002()  "{{{1
  let expected_key_table = s:expected_key_table
  Title let _ = ku#file#key_table('xyzzy')  " {ext} is not used.
  Assert type(_) ==> type({})
  Assert _ ==> expected_key_table
endfunction




function s:test_ku_file_gather_items_0001()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', '')  " Current directory
  Assert type(_) ==> type([])
  Assert len(_) ==> 6
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1']
endfunction




function s:test_ku_file_gather_items_0002()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', 'money')  " Last component is ignored
  Assert type(_) ==> type([])
  Assert len(_) ==> 6
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1']
endfunction




function s:test_ku_file_gather_items_0003()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', '.')  " Dot items now appear.
  Assert type(_) ==> type([])
  Assert len(_) ==> 8
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1',
  \ '..', '.file1']
endfunction




function s:test_ku_file_gather_items_0004()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', '.money')  " Only '.' matters.
  Assert type(_) ==> type([])
  Assert len(_) ==> 8
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1',
  \ '..', '.file1']
endfunction




function s:test_ku_file_gather_items_0005()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', 'money.')  " Only first '.' matters.
  Assert type(_) ==> type([])
  Assert len(_) ==> 6
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1']
endfunction




function s:test_ku_file_gather_items_0006()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('No such dir', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 0
endfunction




function s:test_ku_file_gather_items_0007()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('file1', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 0
endfunction




function s:test_ku_file_gather_items_0008()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', 'dir1')  " Not traversed w/ this pat.
  Assert type(_) ==> type([])
  Assert len(_) ==> 6
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1']
endfunction




function s:test_ku_file_gather_items_0009()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('dir1', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0].word ==> ku#make_path('dir1', 'dir2')
  Assert _[1].word ==> ku#make_path('dir1', 'file2')
endfunction




function s:test_ku_file_gather_items_0010()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('dir1', 'ignored'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0].word ==> ku#make_path('dir1', 'dir2')
  Assert _[1].word ==> ku#make_path('dir1', 'file2')
endfunction




function s:test_ku_file_gather_items_0011()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('dir1', '. aappeared!'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 4
  Assert type(_[0]) ==> type({})

  Assert _[0].word ==> ku#make_path('dir1', 'dir2')
  Assert _[1].word ==> ku#make_path('dir1', 'file2')
  Assert _[2].word ==> ku#make_path('dir1', '..')
  Assert _[3].word ==> ku#make_path('dir1', '.file2')
endfunction




function s:test_ku_file_gather_items_0012()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('dir1', 'bad . here'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0].word ==> ku#make_path('dir1', 'dir2')
  Assert _[1].word ==> ku#make_path('dir1', 'file2')
endfunction




function s:test_ku_file_gather_items_0013()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('dir1', 'dir2', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 1
  Assert type(_[0]) ==> type({})

  Assert _[0].word ==> ku#make_path('dir1', 'dir2', 'file3')
endfunction




function s:test_ku_file_gather_items_0014()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('dir1', 'dir2', '.'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 3
  Assert type(_[0]) ==> type({})

  Assert _[0].word ==> ku#make_path('dir1', 'dir2', 'file3')
  Assert _[1].word ==> ku#make_path('dir1', 'dir2', '..')
  Assert _[2].word ==> ku#make_path('dir1', 'dir2', '.file3')
endfunction




function s:test_ku_file_gather_items_0015()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#path_separator())
  Assert type(_) ==> type([])
  Assert 0 < len(_) ==> 1
  Assert type(_[0]) ==> type({})

  Assert len(filter(copy(_), 'v:val.word == ku#path_separator() . ".."')) ==> 0
endfunction




function s:test_ku_file_gather_items_0016()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('', '.'))
  Assert type(_) ==> type([])
  Assert 0 < len(_) ==> 1
  Assert type(_[0]) ==> type({})

  Assert len(filter(copy(_), 'v:val.word == ku#path_separator() . ".."')) ==> 0
endfunction




function s:test_ku_file_gather_items_0017()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('Yes, {ext} is ignored', '')
  Assert type(_) ==> type([])
  Assert len(_) ==> 6
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1']
endfunction




function s:test_ku_file_gather_items_1001()  "{{{1
  call ku#file#on_source_enter('')

  " The content of a.zip is NOT listed with this pattern.
  Title let _ = ku#file#gather_items('', ku#make_path('a.zip'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 6
  Assert type(_[0]) ==> type({})

  Assert map(copy(_), 'v:val.word')
  \ ==> ['a.zip', 'b.zip', 'c.zip', 'dir1', 'dir1.zip', 'file1']
endfunction




function s:test_ku_file_gather_items_1002()  "{{{1
  call ku#file#on_source_enter('')

  " Now the content of a.zip is listed with this pattern.
  Title let _ = ku#file#gather_items('', ku#make_path('a.zip', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0] ==> {
  \ 'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('a.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('a', 'foo.txt'),
  \ }
  Assert _[1] ==> {
  \ 'word': ku#make_path('a.zip', 'a', 'foofoo.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('a.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('a', 'foofoo.txt'),
  \ }
endfunction




function s:test_ku_file_gather_items_1003()  "{{{1
  call ku#file#on_source_enter('')

  " Trailing part is just ignored.
  Title let _ = ku#file#gather_items('', ku#make_path('a.zip', 'foo'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0] ==> {
  \ 'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('a.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('a', 'foo.txt'),
  \ }
  Assert _[1] ==> {
  \ 'word': ku#make_path('a.zip', 'a', 'foofoo.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('a.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('a', 'foofoo.txt'),
  \ }
endfunction




function s:test_ku_file_gather_items_1004()  "{{{1
  call ku#file#on_source_enter('')

  " Trailing part is just ignored.
  Title let _ = ku#file#gather_items('', ku#make_path('a.zip', 'foo', 'bar'))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0] ==> {
  \ 'word': ku#make_path('a.zip', 'a', 'foo.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('a.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('a', 'foo.txt'),
  \ }
  Assert _[1] ==> {
  \ 'word': ku#make_path('a.zip', 'a', 'foofoo.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('a.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('a', 'foofoo.txt'),
  \ }
endfunction




function s:test_ku_file_gather_items_1005()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('b.zip', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0] ==> {
  \ 'word': ku#make_path('b.zip', 'bar.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('b.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('bar.txt'),
  \ }
  Assert _[1] ==> {
  \ 'word': ku#make_path('b.zip', 'barbar.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('b.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('barbar.txt'),
  \ }
endfunction




function s:test_ku_file_gather_items_1006()  "{{{1
  call ku#file#on_source_enter('')

  Title let _ = ku#file#gather_items('', ku#make_path('c.zip', ''))
  Assert type(_) ==> type([])
  Assert len(_) ==> 2
  Assert type(_[0]) ==> type({})

  Assert _[0] ==> {
  \ 'word': ku#make_path('c.zip', 'c', 'baz.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('c.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('c', 'baz.txt'),
  \ }
  Assert _[1] ==> {
  \ 'word': ku#make_path('c.zip', 'd', 'bazbaz.txt'),
  \ 'menu': 'in archive',
  \ 'ku_file_archive_format': 'zip',
  \ 'ku_file_archive_path': ku#make_path('c.zip'),
  \ 'ku_file_archive_content_path': ku#make_path('d', 'bazbaz.txt'),
  \ }
endfunction




function s:test_ku_file_on_source_enter_0001()  "{{{1
  let VARS = ku#file#_local_variables()

  Title let _ = ku#file#on_source_enter('')
  Assert _ ==> 0
  Assert VARS.cached_items ==> {}
endfunction




function s:test_ku_file_on_source_enter_0002()  "{{{1
  let VARS = ku#file#_local_variables()

  Title let VARS.cached_items.foo = 'bar'
  Assert VARS.cached_items.foo ==> 'bar'
  Assert VARS.cached_items ==> {'foo': 'bar'}
  Assert ku#file#on_source_enter('') ==> 0
  Assert VARS.cached_items ==> {}
endfunction




function s:test_ku_file_special_char_p_0001()  "{{{1
  let chars = map(range(0x100), 'nr2char(v:val)')

  Title let _ = map(chars, "ku#file#special_char_p('', v:val)")
  Assert type(_) ==> type([])
  Assert type(_[0]) ==> type(0)

    " By the default value of g:ku_component_separators.
  Assert _[char2nr('/')] ==> 1
  Assert _[char2nr('\')] ==> 1
  Assert _[char2nr(':')] ==> 1
    " By ku source file itself.
  Assert _[char2nr('.')] ==> 1

  let _[0x00] = 0  " Ignore NUL, because Vim script cannot handle it.
  let sum = 0
  for i in _
    let sum += abs(i)
  endfor
    " So the rest of characters are not special ones.
  Assert sum ==> 4
endfunction




function s:test_ku_file_special_char_p_0002()  "{{{1
  let chars = map(range(0x100), 'nr2char(v:val)')

  Title let _ = map(chars, "ku#file#special_char_p('xyzzy', v:val)")
  Assert type(_) ==> type([])
  Assert type(_[0]) ==> type(0)

    " By the default value of g:ku_component_separators.
  Assert _[char2nr('/')] ==> 1
  Assert _[char2nr('\')] ==> 1
  Assert _[char2nr(':')] ==> 1
    " By ku source file itself.
  Assert _[char2nr('.')] ==> 1

  let _[0x00] = 0  " Ignore NUL, because Vim script cannot handle it.
  let sum = 0
  for i in _
    let sum += abs(i)
  endfor
    " So the rest of characters are not special ones.
  Assert sum ==> 4
endfunction




function s:test_ku_file_special_char_p_0003()  "{{{1
  let chars = ['', 'foo', ':\/', g:ku_component_separators]

  Title let _ = map(chars, "ku#file#special_char_p('', v:val)")
  Assert type(_) ==> type([])
  Assert type(_[0]) ==> type(0)

    " FIXME: Null string should not be accepcted.
  Assert _[0] ==> 1

    " Not a single-character string.  Rejected.
  Assert _[1] ==> 0
  Assert _[2] ==> 0

    " FIXME: Not a single-character string, but accepted
    "        because of the use of stridx().
  Assert _[3] ==> 1
endfunction




function s:test_ku_file_special_char_p_0004()  "{{{1
  let chars = ['', 'foo', ':\/', g:ku_component_separators]

  Title let _ = map(chars, "ku#file#special_char_p('xyzzy', v:val)")
  Assert type(_) ==> type([])
  Assert type(_[0]) ==> type(0)

    " FIXME: Null string should not be accepcted.
  Assert _[0] ==> 1

    " Not a single-character string.  Rejected.
  Assert _[1] ==> 0
  Assert _[2] ==> 0

    " FIXME: Not a single-character string, but accepted
    "        because of the use of stridx().
  Assert _[3] ==> 1
endfunction




function s:test_parse_pattern_0001()  "{{{1
  Title let _ = Call('s:parse_pattern', '')
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0002()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('foo'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['foo']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0003()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('foo', 'bar'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['foo', 'bar']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0004()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('foo', 'bar', 'baz'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['foo', 'bar', 'baz']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0005()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('.foo', 'bar', 'baz'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['.foo', 'bar', 'baz']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0006()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('.foo', '.bar', 'baz'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['.foo', '.bar', 'baz']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0007()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('.foo', '.bar', '.baz'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['.foo', '.bar', '.baz']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 1
endfunction




function s:test_parse_pattern_0008()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('.foo'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['.foo']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 1
endfunction




function s:test_parse_pattern_0009()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('', ''))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['', '']
  Assert _.root_directory_pattern_p ==> 1
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0010()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('', 'foo'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['', 'foo']
  Assert _.root_directory_pattern_p ==> 1
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0011()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('', 'foo', 'bar'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['', 'foo', 'bar']
  Assert _.root_directory_pattern_p ==> 1
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_0012()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('', 'foo', '.bar'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['', 'foo', '.bar']
  Assert _.root_directory_pattern_p ==> 1
  Assert _.user_seems_want_dotfiles_p ==> 1
endfunction




function s:test_parse_pattern_1001()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('a.zip'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['a.zip']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_1002()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('.a.zip'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['.a.zip']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 1
endfunction




function s:test_parse_pattern_1003()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('', 'a.zip'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['', 'a.zip']
  Assert _.root_directory_pattern_p ==> 1
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_1004()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('', '.a.zip'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['', '.a.zip']
  Assert _.root_directory_pattern_p ==> 1
  Assert _.user_seems_want_dotfiles_p ==> 1
endfunction




function s:test_parse_pattern_1005()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('a.zip', ''))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'archive'
  Assert _.components ==> ['a.zip', '']
  Assert _.archive_format ==> 'zip'
  Assert _.leading_part ==> ku#make_path('a.zip')
endfunction




function s:test_parse_pattern_1006()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('a.zip', 'bar', 'baz'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'archive'
  Assert _.components ==> ['a.zip', 'bar', 'baz']
  Assert _.archive_format ==> 'zip'
  Assert _.leading_part ==> ku#make_path('a.zip')
endfunction




function s:test_parse_pattern_1007()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('dir1.zip'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['dir1.zip']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 0
endfunction




function s:test_parse_pattern_1008()  "{{{1
  Title let _ = Call('s:parse_pattern', ku#make_path('dir1.zip', '.xxx'))
  Assert type(_) ==> type({})
  Assert len(keys(_)) ==> 4
  Assert _.type ==> 'directory'
  Assert _.components ==> ['dir1.zip', '.xxx']
  Assert _.root_directory_pattern_p ==> 0
  Assert _.user_seems_want_dotfiles_p ==> 1
endfunction




" Entities which are not tested yet  "{{{1
"
" Actions
" s:open(bang, item)
" ku#file#action_open(item)
" ku#file#action_open_x(item)




Test  "{{{1

" __END__
" vim: filetype=vim foldmethod=marker
