" Test: vim-ku basic
" Set up  "{{{1

let s:SID_PREFIX = ku#_sid_prefix()

function Call(function_name, ...)
  return call(substitute(a:function_name, '^s:', s:SID_PREFIX, ''), a:000)
endfunction


let s:VARS = ku#_local_variables()

function! Ref(variable_name)
  return s:VARS[a:variable_name]
endfunction

function! Set(variable_name, value)
  let s:VARS[a:variable_name] = a:value
endfunction


command! NewBuffer  bwipeout! | enew!




function s:test_ku_available_source_p()  "{{{1
  Title "ku#available_source_p()"

  let F = function('function')
  let G = function('type')
  call Set('available_sources', {})

  " Initial state.
  Assert ku#available_sources() ==> {}
  Assert ku#available_source_names() ==> []
  Assert ku#available_source_p('test') ==> 0
  Assert ku#available_source_p('abc') ==> 0
  Assert ku#available_source_p('NoSuchSource') ==> 0

  " Define a source (ordinary case).
  Assert ku#define_source({'gather_candidates': F, 'name': 'test'}) ==> 1
  Assert ku#available_source_names() ==> ['test']
  Assert ku#available_source_p('test') ==> 1
  Assert ku#available_source_p('abc') ==> 0
  Assert ku#available_source_p('NoSuchSource') ==> 0

  " Override an existing source.
  Assert ku#define_source({'gather_candidates': G, 'name': 'test'}) ==> 1
  Assert ku#available_source_names() ==> ['test']
  Assert ku#available_source_p('test') ==> 1
  Assert ku#available_source_p('abc') ==> 0
  Assert ku#available_source_p('NoSuchSource') ==> 0

  " Define more source.
  Assert ku#define_source({'gather_candidates': F, 'name': 'abc'}) ==> 1
  Assert ku#available_source_names() ==> ['abc', 'test']
  Assert ku#available_source_p('test') ==> 1
  Assert ku#available_source_p('abc') ==> 1
  Assert ku#available_source_p('NoSuchSource') ==> 0

  " Reset side effect for further tests.
  call Set('available_sources', {})
endfunction




function s:test_ku_available_source_names()  "{{{1
  Title "ku#available_source_names()"

  let F = function('function')
  let G = function('type')
  call Set('available_sources', {})

  " Initial state.
  Assert ku#available_sources() ==> {}
  Assert ku#available_source_names() ==> []

  " Define a source (ordinary case).
  Assert ku#define_source({'gather_candidates': F, 'name': 'test'}) ==> 1
  Assert ku#available_source_names() ==> ['test']

  " Override an existing source.
  Assert ku#define_source({'gather_candidates': G, 'name': 'test'}) ==> 1
  Assert ku#available_source_names() ==> ['test']

  " Define more source.
  Assert ku#define_source({'gather_candidates': F, 'name': 'abc'}) ==> 1
  Assert ku#available_source_names() ==> ['abc', 'test']

  " Reset side effect for further tests.
  call Set('available_sources', {})
endfunction




function s:test_ku_available_sources()  "{{{1
  Title "ku#available_sources()"

  let F = function('function')
  let G = function('type')
  call Set('available_sources', {})

  " Initial state.
  Assert ku#available_sources() ==> {}
  Assert ku#available_sources() ==> Ref('available_sources')

  " Define a source (bad cases).
  Assert ku#define_source({}) ==> 0
  Assert ku#define_source({'gather_candidates': 0, 'name': 0}) ==> 0
  Assert ku#define_source({'gather_candidates': 0, 'name': 'test'}) ==> 0
  Assert ku#define_source({'gather_candidates': F, 'name': 0}) ==> 0
  Assert sort(keys(ku#available_sources())) ==> []
  Assert ku#available_sources() ==> Ref('available_sources')

  " Define a source (ordinary case).
  Assert ku#define_source({'gather_candidates': F, 'name': 'test'}) ==> 1
  Assert sort(keys(ku#available_sources())) ==> ['test']
  Assert ku#available_sources() ==> Ref('available_sources')

  " Override an existing source.
  Assert ku#define_source({'gather_candidates': G, 'name': 'test'}) ==> 1
  Assert sort(keys(ku#available_sources())) ==> ['test']
  Assert ku#available_sources() ==> Ref('available_sources')

  " Reset side effect for further tests.
  call Set('available_sources', {})
endfunction




function s:test_ku_custom_actioin()  "{{{1
  Title "ku#custom_action()"

  " Initialize.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}

  call Set('available_kinds', {})
  Assert ku#define_kind({
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ }) ==> 1
  Assert Ref('available_kinds') ==> {
  \ 'file': {
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ },
  \ }

  " Normal case: Using s:custom_action_1()
  Assert ku#custom_action('file', 'ai', function('len')) ==> 0
  Assert ku#custom_action('file', 'ai', function('get')) ==> function('len')

  " Normal case: Using s:custom_action_2()
  Assert ku#custom_action('file', 'default', 'file', 'get') ==> 0
  Assert ku#custom_action('file', 'default', 'file', 'get') ==> function('get')

  " Strange case: Using s:custom_action_2() with many extra arguments
  Assert ku#custom_action('file', 'new', 'file', 'get', '') ==> 0
  Assert ku#custom_action('file', 'new', 'file', 'get', '') ==> function('get')

  " So the internal is:
  Assert Ref('custom_kind_action_tables') ==> {
  \ 'file': {
  \ 'ai': function('get'),
  \ 'default': function('get'),
  \ 'new': function('get'),
  \ },
  \ }
  Assert Ref('available_kinds') ==> {
  \ 'file': {
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ },
  \ }

  " Reset side effect.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}
endfunction




function s:test_ku_custom_key()  "{{{1
  Title "ku#custom_key()"

  " Initialize.
  call Set('custom_kind_key_tables', {})
  Assert Ref('custom_kind_key_tables') ==> {}

  " Define a few key bindings for kind "buffer" - valid name.
  Assert ku#custom_key('buffer', '<', 'lt') ==> 0
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'lt'}
  Assert ku#custom_key('buffer', '>', 'gt') ==> 0
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'lt', '>': 'gt'}

  " Override a key bindings for kind "buffer".
  Assert ku#custom_key('buffer', '<', 'LT') ==> 'lt'
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'LT', '>': 'gt'}
  Assert ku#custom_key('buffer', '>', 'GT') ==> 'gt'
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'LT', '>': 'GT'}

  " Define a few key bindings for kind "!@#$%" - invalid name but not checked.
  Assert ku#custom_key('!@#$%', '(', 'lb') ==> 0
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'lb'}
  Assert ku#custom_key('!@#$%', ')', 'rb') ==> 0
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'lb', ')': 'rb'}

  " Override a key bindings for kind "!@#$%".
  Assert ku#custom_key('!@#$%', '(', 'LB') ==> 'lb'
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'LB', ')': 'rb'}
  Assert ku#custom_key('!@#$%', ')', 'RB') ==> 'rb'
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'LB', ')': 'RB'}

  " So the result is:
  Assert Ref('custom_kind_key_tables') ==> {
  \ 'buffer': {'<': 'LT', '>': 'GT'},
  \ '!@#$%': {'(': 'LB', ')': 'RB'},
  \ }

  " Reset side effect.
  call Set('custom_kind_key_tables', {})
  Assert Ref('custom_kind_key_tables') ==> {}
endfunction




function s:test_ku_define_default_ui_key_mappings()  "{{{1
  Title "ku#define_default_ui_key_mappings()"

  NewBuffer

  " Initial state.
  nnoremap <buffer> <C-c>  QUIT-NORMAL
  inoremap <buffer> <C-c>  QUIT-INSERT
  Assert maparg('<C-c>', 'i') ==> 'QUIT-INSERT'
  Assert maparg('<C-c>', 'n') ==> 'QUIT-NORMAL'
  Assert maparg('<C-i>', 'i') ==> ''
  Assert maparg('<C-i>', 'n') ==> ''
  Assert maparg('<C-m>', 'i') ==> ''
  Assert maparg('<C-m>', 'n') ==> ''
  Assert maparg('<Enter>', 'i') ==> ''
  Assert maparg('<Enter>', 'n') ==> ''
  Assert maparg('<Return>', 'i') ==> ''
  Assert maparg('<Return>', 'n') ==> ''
  Assert maparg('<Tab>', 'i') ==> ''
  Assert maparg('<Tab>', 'n') ==> ''

  " Define - don't override.
  call ku#define_default_ui_key_mappings(0)
  Assert maparg('<C-c>', 'i') ==> 'QUIT-INSERT'
  Assert maparg('<C-c>', 'n') ==> 'QUIT-NORMAL'
  Assert maparg('<C-i>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-i>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-m>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<C-m>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Tab>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<Tab>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'

  " Define - may override.
  call ku#define_default_ui_key_mappings(1)
  Assert maparg('<C-c>', 'i') ==> '<Plug>(ku-quit-session)'
  Assert maparg('<C-c>', 'n') ==> '<Plug>(ku-quit-session)'
  Assert maparg('<C-i>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-i>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-m>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<C-m>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Tab>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<Tab>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'
endfunction




function s:test_ku_define_kind()  "{{{1
  Title "ku#define_kind()"

  " Initialize
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}

  " Define a kind - error cases.
  Assert ku#define_kind({
  \ 'default_key_table': {},
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ }) ==> 0

  Assert ku#define_kind({
  \ 'default_action_table': 0,
  \ 'default_key_table': {},
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'default_key_table': 0,
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'name': 0,
  \ }) ==> 0

  Assert Ref('available_kinds') ==> {}

  " Define a few kinds - valid cases.
  Assert ku#define_kind({
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer',
  \ }) ==> 1
  Assert ku#define_kind({
  \ 'default_action_table': {'open': function('type')},
  \ 'default_key_table': {'o': 'open'},
  \ 'name': 'file',
  \ }) ==> 1

  Assert Ref('available_kinds') ==> {
  \ 'buffer': {
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer'
  \ },
  \ 'file': {
  \ 'default_action_table': {'open': function('type')},
  \ 'default_key_table': {'o': 'open'},
  \ 'name': 'file'
  \ },
  \ }

  " Override a kind.
  Assert ku#define_kind({
  \ 'default_action_table': {'despair': function('type')},
  \ 'default_key_table': {'d': 'despair'},
  \ 'name': 'file',
  \ }) ==> 1

  Assert Ref('available_kinds') ==> {
  \ 'buffer': {
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer'
  \ },
  \ 'file': {
  \ 'default_action_table': {'despair': function('type')},
  \ 'default_key_table': {'d': 'despair'},
  \ 'name': 'file'
  \ },
  \ }

  " Reset side effect.
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}
endfunction




function s:test_ku_define_source()  "{{{1
  Title "ku#define_source()"

  let F = function('function')
  let G = function('type')
  let matchers = [function('ku#matcher#default#matches_p')]
  let sorters = [function('ku#sorter#default#sort')]
  call Set('available_sources', {})
  call Set('available_kinds', {})

  " Initial state.
  Assert Ref('available_sources') ==> {}
  Assert Ref('available_kinds') ==> {}

  " Define a source (bad cases).
  Assert ku#define_source({}) ==> 0
  Assert ku#define_source({'gather_candidates': 0, 'name': 0}) ==> 0
  Assert ku#define_source({'gather_candidates': 0, 'name': 'test'}) ==> 0
  Assert ku#define_source({'gather_candidates': F, 'name': 0}) ==> 0
  Assert Ref('available_sources') ==> {}
  Assert Ref('available_kinds') ==> {}

  " Define a source (ordinary case).
  Assert ku#define_source({'gather_candidates': F, 'name': 'test'}) ==> 1
  Assert Ref('available_sources')['test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'filters': [],
  \ 'gather_candidates': F,
  \ 'kinds': ['source/test'],
  \ 'matchers': matchers,
  \ 'name': 'test',
  \ 'sorters': sorters,
  \ }
  Assert Ref('available_kinds')['source/test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'name': 'source/test',
  \ }

  " Override an existing source.
  Assert ku#define_source({'gather_candidates': G, 'name': 'test'}) ==> 1
  Assert Ref('available_sources')['test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'filters': [],
  \ 'gather_candidates': G,
  \ 'kinds': ['source/test'],
  \ 'matchers': matchers,
  \ 'name': 'test',
  \ 'sorters': sorters,
  \ }
  Assert Ref('available_kinds')['source/test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'name': 'source/test',
  \ }

  " With optional attributes.
  Assert ku#define_source({
  \ 'default_action_table': {'checkout': function('function')},
  \ 'default_key_table': {'/': 'checkout'},
  \ 'filters': [G],
  \ 'gather_candidates': F,
  \ 'kinds': ['git', 'file'],
  \ 'matchers': [G],
  \ 'name': 'test',
  \ 'sorters': [F]})
  \ ==> 1
  Assert Ref('available_sources')['test']
  \ ==> {
  \ 'default_action_table': {'checkout': function('function')},
  \ 'default_key_table': {'/': 'checkout'},
  \ 'filters': [G],
  \ 'gather_candidates': F,
  \ 'kinds': ['source/test', 'git', 'file'],
  \ 'matchers': [G],
  \ 'name': 'test',
  \ 'sorters': [F],
  \ }
  Assert Ref('available_kinds')['source/test']
  \ ==> {
  \ 'default_action_table': {'checkout': function('function')},
  \ 'default_key_table': {'/': 'checkout'},
  \ 'name': 'source/test',
  \ }

  " Reset side effect for further tests.
  call Set('available_sources', {})
  call Set('available_kinds', {})
endfunction




function s:test_ku_omnifunc()  "{{{1
  Title "ku#omnifunc()"

  "" a:findstart == 1

  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  " Case 1: Default state - there is only the prompt.
  " ku#start() has reset the content of the ku buffer.
  " So that the prompt must be in the ku buffer.
  Assert ku#omnifunc(1, '') ==> 1

  " Case 2: The prompt and some characters.
  normal! Amane
  Assert ku#omnifunc(1, '') ==> 1

  " Case 3: No character.
  normal! 0d$
  Assert ku#omnifunc(1, '') ==> 0

  " Case 4: No prompt, some characters.
  normal! Amane
  Assert ku#omnifunc(1, '') ==> 0

  close

  "" a:findstart == 0

  " Case 1: No source.
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert ku#omnifunc(0, 'pattern') ==> []

  close

  " Case 2: With a source - to check use of the current sources.
  let source = {}
  let source.name = 'test'
  function! source.gather_candidates(args)
    return [{'word': a:args.pattern, 'abbr': a:args.pattern[:2-1]}]
  endfunction
  Assert ku#define_source(source) ==> 1
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert ku#omnifunc(0, 'pattern') ==> [{'word': 'pattern', 'abbr': 'pa'}]

  close
  call Set('available_sources', {})

  " Reset side effect.
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  bwipeout!
endfunction




function s:test_ku_start()  "{{{1
  Title "ku#start()"

  " Initial state.
  NewBuffer
  let first_bufnr = bufnr('')

  Assert &l:buftype ==> ''
  Assert winnr('$') ==> 1
  Assert winnr() ==> 1

  " Case 1: The ku buffer is not created.
  call feedkeys('abc', 't')
  Assert ku#start() ==> 1
  let second_bufnr = bufnr('')

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> 'a'
  Assert nr2char(getchar(0)) ==> 'b'
  Assert nr2char(getchar(0)) ==> 'c'
  Assert nr2char(getchar(0)) ==> ''

  Assert &g:completeopt ==> 'menu,menuone'
  Assert &l:filetype ==> 'ku'
  Assert [line('.'), col('.')] ==> [2, 1]
  Assert bufnr('') != first_bufnr ==> 1
  Assert getline(1, line('$')) ==> ['', '>']
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 2: The ku buffer is already created.
  close
  Assert ku#start() ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') ==> second_bufnr
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 3: The ku buffer has been deleted.
  noautocmd bwipeout!  " :noautocmd to avoid calling event handlers.
  Assert ku#start() ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') != first_bufnr ==> 1
  Assert bufnr('') != second_bufnr ==> 1
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 4: With {sources}.
  close
  Assert ku#start() ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  Assert winnr() ==> 1
  Assert winnr('$') ==> 2

  " Case 5: With {sources} including invalid values.
  close
  Assert ku#start(['invalid']) ==> 0

  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') ==> first_bufnr
  Assert winnr('$') ==> 1
  Assert winnr() ==> 1

  " Case 6: With {initial-pattern}.
  Assert ku#start(0, 'def') ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') != first_bufnr ==> 1
  Assert getline(1, line('$')) ==> ['', '>def']
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 7: Calling ku#start() while the ku buffer is active.
  Assert ku#start() ==> 0

  Assert nr2char(getchar(0)) ==> ''

  " FIXME: NTY: If there is some text in the ku buffer.
  " FIXME: NTY: If there is no room to create a new window.

  " Reset side effect.
  noautocmd bwipeout!  " :noautocmd to avoid calling event handlers.
endfunction




function s:test_s_candidates_from_pattern()  "{{{1
  Title "s:candidates_from_pattern()"

  function! Test_matcher_always(...)
    return 1
  endfunction

  let source_a = {}
  let source_a.name = 'source_a'
  function! source_a.gather_candidates(args)
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.sorters = []
  let source_a.matchers = [function('Test_matcher_always')]
  let source_a.filters = []

  let source_b = {}
  let source_b.name = 'source_b'
  function! source_b.gather_candidates(args)
    return [{'word': 'b'}, {'word': 'B'}]
  endfunction
  let source_b.sorters = []
  let source_b.matchers = [function('Test_matcher_always')]
  let source_b.filters = []

  let source_c = {}
  let source_c.name = 'source_c'
  function! source_c.gather_candidates(args)
    return [{'word': 'u'}, {'word': 'p'}]
  endfunction
  let source_c.sorters = [function('ku#sorter#simple#sort')]
  let source_c.matchers = [function('Test_matcher_always')]
  let source_c.filters = []

  " Case 1: No source.
  Assert Call('s:candidates_from_pattern', '2330', []) ==> []

  " Case 2: A source.
  Assert Call('s:candidates_from_pattern', '2330', [source_a])
  \ ==> [{'word': '2330'}]

  " Case 3: Multiple sources.
  Assert Call('s:candidates_from_pattern', '2330', [source_a, source_b])
  \ ==> [{'word': '2330'}, {'word': 'b'}, {'word': 'B'}]

  " Case 4: Multiple sources - duplicate sources.
  " (although this case is not a valid usage)
  Assert Call('s:candidates_from_pattern','2330',[source_a,source_b,source_a])
  \ ==> [{'word': '2330'}, {'word': 'b'}, {'word': 'B'}, {'word': '2330'}]

  " Case 5: A source with sorters.
  Assert Call('s:candidates_from_pattern', '2330', [source_c])
  \ ==> [{'word': 'p'}, {'word': 'u'}]

  " Case 6: A source with sorters and a source without sorters.
  Assert Call('s:candidates_from_pattern', '2330', [source_c, source_b])
  \ ==> [{'word': 'p'}, {'word': 'u'}, {'word': 'b'}, {'word': 'B'}]
endfunction




function s:test_s_custom_action_1()  "{{{1
  Title "s:custom_action_1()"

  " Initialize.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}

  " Define an action.
  Assert Call('s:custom_kind_action_table', 'file') ==> {}
  Assert Call('s:custom_action_1', 'file', 'ai', function('len')) ==> 0
  Assert Call('s:custom_kind_action_table', 'file') ==> {'ai': function('len')}
  Assert Ref('custom_kind_action_tables') ==> {'file': {'ai': function('len')}}

  " Override an existing action.
  Assert Call('s:custom_action_1', 'file', 'ai', function('get'))
  \ ==> function('len')
  Assert Call('s:custom_kind_action_table', 'file') ==> {'ai': function('get')}
  Assert Ref('custom_kind_action_tables') ==> {'file': {'ai': function('get')}}

  " Reset side effect.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}
endfunction




function s:test_s_custom_action_2()  "{{{1
  Title "s:custom_action_2()"

  " Initialize.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}

  " Error cases.
  Assert Call('s:custom_action_2', 'file', 'name1', 'kind2', 'name2') ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ }) ==> 1
  Assert Call('s:custom_action_2', 'file', 'name1', 'file', 'name2') ==> 0

  " Define an action.
  Assert Call('s:custom_kind_action_table', 'file') ==> {}

  Assert Call('s:custom_action_2', 'file', 'default', 'file', 'get') ==> 0

  Assert Call('s:custom_kind_action_table', 'file')
  \ ==> {'default': function('get')}
  Assert Ref('custom_kind_action_tables')
  \ ==> {'file': {'default': function('get')}}

  " Override an existing action.
  Assert Call('s:custom_action_2', 'file', 'default', 'file', 'len')
  \ ==> function('get')

  Assert Call('s:custom_kind_action_table', 'file')
  \ ==> {'default': function('len')}
  Assert Ref('custom_kind_action_tables')
  \ ==> {'file': {'default': function('len')}}

  " Reset side effect.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}
endfunction




function s:test_s_custom_kind_action_table()  "{{{1
  Title "s:custom_kind_action_table()"

  " Initialize.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}

  " Refer the custom action table for "file" - valid name.
  let custom_file_action_table = Call('s:custom_kind_action_table', 'file')
  Assert custom_file_action_table ==> {}
  Assert Ref('custom_kind_action_tables') ==> {'file': {}}
  let custom_file_action_table_2 = Call('s:custom_kind_action_table', 'file')
  Assert custom_file_action_table is custom_file_action_table_2 ==> 1
  Assert Ref('custom_kind_action_tables') ==> {'file': {}}

  " Refer the custom action table for "!@#$%" - invalid name but not checked.
  let custom_xxxxx_action_table = Call('s:custom_kind_action_table', '!@#$%')
  Assert custom_xxxxx_action_table ==> {}
  Assert Ref('custom_kind_action_tables') ==> {'file': {}, '!@#$%': {}}
  let custom_xxxxx_action_table_2 = Call('s:custom_kind_action_table', '!@#$%')
  Assert custom_xxxxx_action_table is custom_xxxxx_action_table_2 ==> 1
  Assert Ref('custom_kind_action_tables') ==> {'file': {}, '!@#$%': {}}

  " Both custom kind action tables are not the same one.
  Assert custom_file_action_table isnot custom_xxxxx_action_table ==> 1

  " Reset side effect.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}
endfunction




function s:test_s_custom_kind_key_table()  "{{{1
  Title "s:custom_kind_key_table()"

  " Initialize.
  call Set('custom_kind_key_tables', {})
  Assert Ref('custom_kind_key_tables') ==> {}

  " Refer the custom key table for "buffer" - valid name.
  let custom_buffer_key_table = Call('s:custom_kind_key_table', 'buffer')
  Assert custom_buffer_key_table ==> {}
  Assert Ref('custom_kind_key_tables') ==> {'buffer': {}}
  let custom_buffer_key_table_2 = Call('s:custom_kind_key_table', 'buffer')
  Assert custom_buffer_key_table is custom_buffer_key_table_2 ==> 1
  Assert Ref('custom_kind_key_tables') ==> {'buffer': {}}

  " Refer the custom key table for "!@#$%" - invalid name but not checked.
  let custom_xxxxx_key_table = Call('s:custom_kind_key_table', '!@#$%')
  Assert custom_xxxxx_key_table ==> {}
  Assert Ref('custom_kind_key_tables') ==> {'buffer': {}, '!@#$%': {}}
  let custom_xxxxx_key_table_2 = Call('s:custom_kind_key_table', '!@#$%')
  Assert custom_xxxxx_key_table is custom_xxxxx_key_table_2 ==> 1
  Assert Ref('custom_kind_key_tables') ==> {'buffer': {}, '!@#$%': {}}

  " Both custom kind key tables are not the same one.
  Assert custom_buffer_key_table isnot custom_xxxxx_key_table ==> 1

  " Reset side effect.
  call Set('custom_kind_key_tables', {})
  Assert Ref('custom_kind_key_tables') ==> {}
endfunction




function s:test_s_default_kind_action_table()  "{{{1
  Title "s:default_kind_action_table()"

  " Initialize.
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}

  " If not defined.
  Assert Call('s:default_kind_action_table', 'buffer') ==> 0

  " If defined.
  let kind_a = {
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer',
  \ }
  Assert ku#define_kind(kind_a) ==> 1

  Assert Call('s:default_kind_action_table', 'buffer')
  \ ==> {'close': function('type')}
  Assert Call('s:default_kind_action_table', 'buffer')
  \ is kind_a.default_action_table
  \ ==> 1

  " Reset side effect.
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}
endfunction




function s:test_s_filter_candidates()  "{{{1
  Title "s:filter_candidates()"

  function! Test_filter_odd(lcandidates, args)
    return filter(a:lcandidates, 'len(v:val.word) % 2')
  endfunction

  function! Test_filter_m(lcandidates, args)
    return filter(a:lcandidates, 'v:val.word =~# "m"')
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'a'},
  \     {'word': 'lm'},
  \     {'word': 'bcd'},
  \     {'word': 'uvwx'},
  \     {'word': 'mnopq'},
  \   ]
  let ARGS = {
  \     'pattern': '',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_EMPTY = {
  \     'filters': [],
  \   }
  let SOURCE_M = {
  \     'filters': [function('Test_filter_m')],
  \   }
  let SOURCE_M_ODD = {
  \     'filters': [function('Test_filter_m'),
  \                 function('Test_filter_odd')],
  \   }
  let SOURCE_ODD = {
  \     'filters': [function('Test_filter_odd')],
  \   }
  let SOURCE_ODD_M = {
  \     'filters': [function('Test_filter_odd'),
  \                 function('Test_filter_m')],
  \   }

  " With no filter.
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_EMPTY)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'lm'},
  \ {'word': 'bcd'},
  \ {'word': 'uvwx'},
  \ {'word': 'mnopq'},
  \ ]

  " With filter M
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M)
  \ ==> [
  \ {'word': 'lm'},
  \ {'word': 'mnopq'},
  \ ]

  " With filter ODD
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'bcd'},
  \ {'word': 'mnopq'},
  \ ]

  " With filter M-ODD and ODD-M
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M_ODD)
  \ ==> [
  \ {'word': 'mnopq'},
  \ ]
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD_M)
  \ ==> Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M_ODD)
endfunction




function s:test_s_get_key()  "{{{1
  Title "s:get_key()"

  " Drop all characters in the typeahead buffer.
  let typeahead = ''
  while getchar(1) isnot 0
    let typeahead .= getchar()
  endwhile
    " Assumption: There is no character in the typeahead buffer.
  Assert typeahead ==> ''

  " Case 1: Ordinary key.
  call feedkeys('a')
  Assert Call('s:get_key') ==> 'a'

  " Case 2: Special key.
  call feedkeys("\<F1>")
  Assert Call('s:get_key') ==> "\<F1>"

  " Case 3: But its internal...
  call feedkeys('Sasara')
  Assert Call('s:get_key') ==> 'Sasara'
endfunction




function s:test_s_initialize_ku_buffer()  "{{{1
  Title "s:initialize_ku_buffer()"

  "" Case 1: Without user's initialization.
  NewBuffer
  call Call('s:initialize_ku_buffer')

  " Basic settings.
  Assert &l:bufhidden ==> 'hide'
  Assert &l:buflisted ==> 0
  Assert &l:buftype ==> 'nofile'
  Assert &l:omnifunc ==> 'ku#omnifunc'
  Assert &l:swapfile ==> 0
  Assert bufname('') ==> Ref('KU_BUFFER_NAME')

  " Autocommands.
  Assert exists('#plugin-ku#BufLeave#<buffer>') ==> 1
  Assert exists('#plugin-ku#CursorMovedI#<buffer>') ==> 1
  Assert exists('#plugin-ku#InsertEnter#<buffer>') ==> 1
  Assert exists('#plugin-ku#TabLeave#<buffer>') ==> 0
  Assert exists('#plugin-ku#WinLeave#<buffer>') ==> 1

  " Key mappings - fundamentals.
  Assert maparg('<BS>', 'i') != '' ==> 1
  Assert maparg('<C-h>', 'i') != '' ==> 1
  Assert maparg('<Plug>(ku-choose-and-do-an-action)', 'i') != '' ==> 1
  Assert maparg('<Plug>(ku-choose-and-do-an-action)', 'n') != '' ==> 1
  Assert maparg('<Plug>(ku-do-the-default-action)', 'i') != '' ==> 1
  Assert maparg('<Plug>(ku-do-the-default-action)', 'n') != '' ==> 1
  Assert maparg('<Plug>(ku-quit-session)', 'i') != '' ==> 1
  Assert maparg('<Plug>(ku-quit-session)', 'n') != '' ==> 1

  " Key mappings - user interaface.
  Assert maparg('<C-c>', 'n') ==> '<Plug>(ku-quit-session)'

  "" Case 2: With user's initialization - by :autocmd
  noautocmd NewBuffer  " :noautocmd to avoid calling event handlers.
  augroup test
    autocmd FileType ku  echo '" autocmd FileType ku'
  augroup END

  call Call('s:initialize_ku_buffer')
  Assert maparg('<C-c>', 'n') ==> ''

  augroup test
    autocmd! FileType ku
  augroup END

  "" Case 3: With user's initialization - by ftplugin
  noautocmd NewBuffer  " :noautocmd to avoid calling event handlers.
  let b:did_ftplugin = 'ku'

  call Call('s:initialize_ku_buffer')
  Assert maparg('<C-c>', 'n') ==> ''

  "" Reset side effect.
  noautocmd bwipeout!  " :noautocmd to avoid calling event handlers.
endfunction




function s:test_s_ku_active_p()  "{{{1
  Title "s:ku_active_p()"

  " Initial state.
  Assert Call('s:ku_active_p') ==> 0

  " After starting a ku session.
  Assert ku#start() ==> 1
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  Assert Call('s:ku_active_p') ==> 1

  " After quitting a ku session.
  close
  Assert Call('s:ku_active_p') ==> 0

  " Reset side effect.
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  noautocmd bwipeout!  " :noautocmd to avoid calling event handlers.
endfunction




function s:test_s_matched_candidates()  "{{{1
  Title "s:matched_candidates()"

  function! Test_matcher_odd(candidate, args)
    return len(a:candidate.word) % 2
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'mk'},
  \     {'word': 'iue'},
  \     {'word': 'kr'},
  \     {'word': 'oom'},
  \     {'word': 'tk'},
  \     {'word': 'oo'},
  \   ]
  let ARGS = {
  \     'pattern': 'm',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_D_O = {
  \     'matchers': [function('ku#matcher#default#matches_p'),
  \                  function('Test_matcher_odd')],
  \   }
  let SOURCE_DEFAULT = {
  \     'matchers': [function('ku#matcher#default#matches_p')],
  \   }
  let SOURCE_EMPTY = {
  \     'matchers': [],
  \   }
  let SOURCE_ODD = {
  \     'matchers': [function('Test_matcher_odd')],
  \   }

  " With no matcher.
  Assert Call('s:matched_candidates', copy(RAW_LCANDIDATES), ARGS,SOURCE_EMPTY)
  \ ==> [
  \ ]

  " With the default matcher.
  Assert Call('s:matched_candidates',copy(RAW_LCANDIDATES),ARGS,SOURCE_DEFAULT)
  \ ==> [
  \ {'word': 'mk'},
  \ {'word': 'oom'},
  \ ]

  " With odd matcher.
  Assert Call('s:matched_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD)
  \ ==> [
  \ {'word': 'iue'},
  \ {'word': 'oom'},
  \ ]

  " With the default matcher + odd matcher.
  Assert Call('s:matched_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_D_O)
  \ ==> [
  \ {'word': 'mk'},
  \ {'word': 'oom'},
  \ {'word': 'iue'},
  \ {'word': 'oom'},
  \ ]
endfunction




function s:test_s_new_session()  "{{{1
  Title "s:new_session()"

  let F = function('function')
  let G = function('type')
  call Set('available_sources', {})
  let original_completeopt = &completeopt
  let original_curwinnr = winnr()
  let original_winrestcmd = winrestcmd()

  " Define sources.
  Assert ku#define_source({'gather_candidates': F, 'name': 'abc'}) ==> 1
  Assert ku#define_source({'gather_candidates': G, 'name': 'test'}) ==> 1
  Assert ku#available_source_p('abc') ==> 1
  Assert ku#available_source_p('test') ==> 1

  " Create a session.
  let session_a = Call('s:new_session', [])
  Assert has_key(session_a, 'id') ==> 1
  Assert session_a.now_quitting_p ==> 0
  Assert session_a.original_completeopt ==> original_completeopt
  Assert session_a.original_curwinnr ==> original_curwinnr
  Assert session_a.original_winrestcmd ==> original_winrestcmd
  Assert session_a.sources ==> []

  " Create another session.
  let session_b = Call('s:new_session', [])
  Assert has_key(session_b, 'id') ==> 1
  Assert session_b.now_quitting_p ==> 0
  Assert session_b.original_completeopt ==> original_completeopt
  Assert session_b.original_curwinnr ==> original_curwinnr
  Assert session_b.original_winrestcmd ==> original_winrestcmd
  Assert session_b.sources ==> []

  " Different session has different id.
  Assert session_b.id isnot session_a.id ==> 1

  " Create a session with some sources.
  let session = Call('s:new_session', ['test', 'abc'])
  Assert has_key(session, 'id') ==> 1
  Assert session.now_quitting_p ==> 0
  Assert session.original_completeopt ==> original_completeopt
  Assert session.original_curwinnr ==> original_curwinnr
  Assert session.original_winrestcmd ==> original_winrestcmd
  Assert session.sources ==> [
  \   ku#available_sources()['test'],
  \   ku#available_sources()['abc']
  \ ]

  " Reset side effect for further tests.
  call Set('available_sources', {})
endfunction




function s:test_s_on_CursorMovedI()  "{{{1
  Title "s:on_CursorMovedI()"

  " FIXME: NIY
  Assert Call('s:on_CursorMovedI') ==> ''
endfunction




function s:test_s_on_InsertEnter()  "{{{1
  Title "s:on_InsertEnter()"

  " FIXME: NIY
  Assert Call('s:on_InsertEnter') ==> ''
endfunction




function s:test_s_quit_session()  "{{{1
  Title "s:quit_session()"

  " Initial state.
  topleft new
  botright new
  set completeopt=preview
  let bufnr = bufnr('')
  let winnr = winnr()
  let winrestcmd = winrestcmd()
  let completeopt = &completeopt

  " After starting a ku session.
  Assert ku#start() ==> 1
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  Assert bufnr('') != bufnr ==> 1
  Assert winnr() != winnr ==> 1
  Assert winrestcmd() != winrestcmd ==> 1
  Assert &completeopt != completeopt ==> 1

  " After quitting a ku session.
  Assert Call('s:quit_session') ==> 1
  let session = Ref('session')
  Assert bufnr('') ==> bufnr
  Assert winnr() ==> winnr
  Assert winrestcmd() ==> winrestcmd
  Assert &completeopt ==> completeopt

  " NTY: recursively called s:quit_session() - but how to test it?

  " Reset side effect.
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  bwipeout!
  only
endfunction




function s:test_s_sort_candidates()  "{{{1
  Title "s:sort_candidates()"

  function! Test_sorter_reverse(lcandidates, args)
    return reverse(a:lcandidates)
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'a'},
  \     {'word': 'l'},
  \     {'word': 'b'},
  \     {'word': 'u'},
  \     {'word': 'm'},
  \   ]
  let ARGS = {
  \     'pattern': '',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_EMPTY = {
  \     'sorters': [],
  \   }
  let SOURCE_REVERSE = {
  \     'sorters': [function('Test_sorter_reverse')],
  \   }
  let SOURCE_S_R = {
  \     'sorters': [function('ku#sorter#simple#sort'),
  \                 function('Test_sorter_reverse')],
  \   }
  let SOURCE_SIMPLE = {
  \     'sorters': [function('ku#sorter#simple#sort')],
  \   }

  " Sort with no sorter.
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_EMPTY)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'l'},
  \ {'word': 'b'},
  \ {'word': 'u'},
  \ {'word': 'm'},
  \ ]

  " Sort with simple sorter.
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_SIMPLE)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'b'},
  \ {'word': 'l'},
  \ {'word': 'm'},
  \ {'word': 'u'},
  \ ]

  " Sort with reverse.
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_REVERSE)
  \ ==> [
  \ {'word': 'm'},
  \ {'word': 'u'},
  \ {'word': 'b'},
  \ {'word': 'l'},
  \ {'word': 'a'},
  \ ]

  " Sort with simple sorter, then sort with reverse
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_S_R)
  \ ==> [
  \ {'word': 'u'},
  \ {'word': 'm'},
  \ {'word': 'l'},
  \ {'word': 'b'},
  \ {'word': 'a'},
  \ ]
endfunction




function s:test_s_valid_key_p()  "{{{1
  Title "s:valid_key_p()"

  " Case 1: Invalid type.
  Assert Call('s:valid_key_p', {}, '8bit', 0) ==> 0

  " Case 2: Key not exists.
  Assert Call('s:valid_key_p', {'8bit': 'rave'}, 0, 'string') ==> 0

  " Case 3: Valid values.
  Assert Call('s:valid_key_p', {'8bit': {}}, '8bit', 'dictionary') ==> 1
  Assert Call('s:valid_key_p', {'8': function('len')}, '8', 'function') ==> 1
  Assert Call('s:valid_key_p', {'8bit': []}, '8bit', 'list') ==> 1
  Assert Call('s:valid_key_p', {'8bit': 3339}, '8bit', 'number') ==> 1
  Assert Call('s:valid_key_p', {'8bit': 'rave'}, '8bit', 'string') ==> 1

  " Case 4: List with valid values.
  Assert Call('s:valid_key_p', {'A': [1, 2, 3]}, 'A', 'list of numbers') ==> 1
  Assert Call('s:valid_key_p', {'A': []}, 'A', 'list of functions') ==> 1
  Assert Call('s:valid_key_p',
  \ {'A': [function('len')]},
  \ 'A',
  \ 'list of functions')
  \ ==> 1

  " Case 5: List with invalid values.
  Assert Call('s:valid_key_p', {'A': [1, 2, 3]}, 'A', 'list of strings') ==> 0
  Assert Call('s:valid_key_p', {'A': [1,'2',3]}, 'A', 'list of numbers') ==> 0
endfunction




Test  "{{{1

" __END__
" vim: filetype=vim foldmethod=marker
