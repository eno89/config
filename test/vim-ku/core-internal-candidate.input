" Test: vim-ku core-internal-candidate
Initialize ku#_sid_prefix() ku#_local_variables()
function s:test_ku_omnifunc()  "{{{1
  Title "ku#omnifunc()"

  ResetContext

  "" a:findstart == 1

  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  " Case 1: Default state - there is only the prompt.
  " ku#start() has reset the content of the ku buffer.
  " So that the prompt must be in the ku buffer.
  Assert ku#omnifunc(1, '') ==> 1

  " Case 2: The prompt and some characters.
  normal! Amane
  Assert ku#omnifunc(1, '') ==> 1

  " Case 3: No character.
  normal! 0d$
  Assert ku#omnifunc(1, '') ==> 0

  " Case 4: No prompt, some characters.
  normal! Amane
  Assert ku#omnifunc(1, '') ==> 0

  close

  "" a:findstart == 0

  " Case 1: No source.
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert ku#omnifunc(0, 'pattern') ==> []

  close

  " Case 2: With a source - to check use of the current sources.
  let source = {}
  let source.name = 'test'
  function! source.gather_candidates(args)
    return [{'word': a:args.pattern, 'abbr': a:args.pattern[:2-1]}]
  endfunction
  Assert ku#define_source(source) ==> 1
  call ku#start()
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert ku#omnifunc(0, 'pattern') ==> [{'word': 'pattern', 'abbr': 'pa'}]

  close

  " Reset side effect.
  Assert ku#start() ==> 1
  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  bwipeout!
endfunction




function s:test_s_candidates_from_pattern()  "{{{1
  Title "s:candidates_from_pattern()"

  ResetContext

  function! Test_matcher_always(...)
    return 1
  endfunction

  let source_a = {}
  let source_a.name = 'source_a'
  function! source_a.gather_candidates(args)
    return [{'word': a:args.pattern}]
  endfunction
  let source_a.sorters = []
  let source_a.matchers = [function('Test_matcher_always')]
  let source_a.filters = []

  let source_b = {}
  let source_b.name = 'source_b'
  function! source_b.gather_candidates(args)
    return [{'word': 'b'}, {'word': 'B'}]
  endfunction
  let source_b.sorters = []
  let source_b.matchers = [function('Test_matcher_always')]
  let source_b.filters = []

  let source_c = {}
  let source_c.name = 'source_c'
  function! source_c.gather_candidates(args)
    return [{'word': 'u'}, {'word': 'p'}]
  endfunction
  let source_c.sorters = [function('ku#sorter#simple#sort')]
  let source_c.matchers = [function('Test_matcher_always')]
  let source_c.filters = []

  " Case 1: No source.
  Assert Call('s:candidates_from_pattern', '2330', []) ==> []

  " Case 2: A source.
  Assert Call('s:candidates_from_pattern', '2330', [source_a])
  \ ==> [{'word': '2330'}]

  " Case 3: Multiple sources.
  Assert Call('s:candidates_from_pattern', '2330', [source_a, source_b])
  \ ==> [{'word': '2330'}, {'word': 'b'}, {'word': 'B'}]

  " Case 4: Multiple sources - duplicate sources.
  " (although this case is not a valid usage)
  Assert Call('s:candidates_from_pattern','2330',[source_a,source_b,source_a])
  \ ==> [{'word': '2330'}, {'word': 'b'}, {'word': 'B'}, {'word': '2330'}]

  " Case 5: A source with sorters.
  Assert Call('s:candidates_from_pattern', '2330', [source_c])
  \ ==> [{'word': 'p'}, {'word': 'u'}]

  " Case 6: A source with sorters and a source without sorters.
  Assert Call('s:candidates_from_pattern', '2330', [source_c, source_b])
  \ ==> [{'word': 'p'}, {'word': 'u'}, {'word': 'b'}, {'word': 'B'}]
endfunction




function s:test_s_filter_candidates()  "{{{1
  Title "s:filter_candidates()"

  ResetContext

  function! Test_filter_odd(lcandidates, args)
    return filter(a:lcandidates, 'len(v:val.word) % 2')
  endfunction

  function! Test_filter_m(lcandidates, args)
    return filter(a:lcandidates, 'v:val.word =~# "m"')
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'a'},
  \     {'word': 'lm'},
  \     {'word': 'bcd'},
  \     {'word': 'uvwx'},
  \     {'word': 'mnopq'},
  \   ]
  let ARGS = {
  \     'pattern': '',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_EMPTY = {
  \     'filters': [],
  \   }
  let SOURCE_M = {
  \     'filters': [function('Test_filter_m')],
  \   }
  let SOURCE_M_ODD = {
  \     'filters': [function('Test_filter_m'),
  \                 function('Test_filter_odd')],
  \   }
  let SOURCE_ODD = {
  \     'filters': [function('Test_filter_odd')],
  \   }
  let SOURCE_ODD_M = {
  \     'filters': [function('Test_filter_odd'),
  \                 function('Test_filter_m')],
  \   }

  " With no filter.
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_EMPTY)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'lm'},
  \ {'word': 'bcd'},
  \ {'word': 'uvwx'},
  \ {'word': 'mnopq'},
  \ ]

  " With filter M
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M)
  \ ==> [
  \ {'word': 'lm'},
  \ {'word': 'mnopq'},
  \ ]

  " With filter ODD
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'bcd'},
  \ {'word': 'mnopq'},
  \ ]

  " With filter M-ODD and ODD-M
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M_ODD)
  \ ==> [
  \ {'word': 'mnopq'},
  \ ]
  Assert Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD_M)
  \ ==> Call('s:filter_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_M_ODD)
endfunction




function s:test_s_matched_candidates()  "{{{1
  Title "s:matched_candidates()"

  ResetContext

  function! Test_matcher_odd(candidate, args)
    return len(a:candidate.word) % 2
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'mk'},
  \     {'word': 'iue'},
  \     {'word': 'kr'},
  \     {'word': 'oom'},
  \     {'word': 'tk'},
  \     {'word': 'oo'},
  \   ]
  let ARGS = {
  \     'pattern': 'm',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_D_O = {
  \     'matchers': [function('ku#matcher#default#matches_p'),
  \                  function('Test_matcher_odd')],
  \   }
  let SOURCE_DEFAULT = {
  \     'matchers': [function('ku#matcher#default#matches_p')],
  \   }
  let SOURCE_EMPTY = {
  \     'matchers': [],
  \   }
  let SOURCE_ODD = {
  \     'matchers': [function('Test_matcher_odd')],
  \   }

  " With no matcher.
  Assert Call('s:matched_candidates', copy(RAW_LCANDIDATES), ARGS,SOURCE_EMPTY)
  \ ==> [
  \ ]

  " With the default matcher.
  Assert Call('s:matched_candidates',copy(RAW_LCANDIDATES),ARGS,SOURCE_DEFAULT)
  \ ==> [
  \ {'word': 'mk'},
  \ {'word': 'oom'},
  \ ]

  " With odd matcher.
  Assert Call('s:matched_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_ODD)
  \ ==> [
  \ {'word': 'iue'},
  \ {'word': 'oom'},
  \ ]

  " With the default matcher + odd matcher.
  Assert Call('s:matched_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_D_O)
  \ ==> [
  \ {'word': 'mk'},
  \ {'word': 'oom'},
  \ {'word': 'iue'},
  \ {'word': 'oom'},
  \ ]
endfunction




function s:test_s_sort_candidates()  "{{{1
  Title "s:sort_candidates()"

  ResetContext

  function! Test_sorter_reverse(lcandidates, args)
    return reverse(a:lcandidates)
  endfunction

  let RAW_LCANDIDATES = [
  \     {'word': 'a'},
  \     {'word': 'l'},
  \     {'word': 'b'},
  \     {'word': 'u'},
  \     {'word': 'm'},
  \   ]
  let ARGS = {
  \     'pattern': '',
  \   }
    " The following sources are actually invalid, but it's enough to test.
  let SOURCE_EMPTY = {
  \     'sorters': [],
  \   }
  let SOURCE_REVERSE = {
  \     'sorters': [function('Test_sorter_reverse')],
  \   }
  let SOURCE_S_R = {
  \     'sorters': [function('ku#sorter#simple#sort'),
  \                 function('Test_sorter_reverse')],
  \   }
  let SOURCE_SIMPLE = {
  \     'sorters': [function('ku#sorter#simple#sort')],
  \   }

  " Sort with no sorter.
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_EMPTY)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'l'},
  \ {'word': 'b'},
  \ {'word': 'u'},
  \ {'word': 'm'},
  \ ]

  " Sort with simple sorter.
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_SIMPLE)
  \ ==> [
  \ {'word': 'a'},
  \ {'word': 'b'},
  \ {'word': 'l'},
  \ {'word': 'm'},
  \ {'word': 'u'},
  \ ]

  " Sort with reverse.
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_REVERSE)
  \ ==> [
  \ {'word': 'm'},
  \ {'word': 'u'},
  \ {'word': 'b'},
  \ {'word': 'l'},
  \ {'word': 'a'},
  \ ]

  " Sort with simple sorter, then sort with reverse
  Assert Call('s:sort_candidates', copy(RAW_LCANDIDATES), ARGS, SOURCE_S_R)
  \ ==> [
  \ {'word': 'u'},
  \ {'word': 'm'},
  \ {'word': 'l'},
  \ {'word': 'b'},
  \ {'word': 'a'},
  \ ]
endfunction




Test  "{{{1

" __END__
" vim: filetype=vim foldmethod=marker
