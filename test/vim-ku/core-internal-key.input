" Test: vim-ku core-internal-key
runtime! plugin/ku.vim plugin/ku/**/*.vim
call vspec#hint({'scope': 'ku#_local_variables()', 'sid': 'ku#_sid_prefix()'})
function s:describe__s_custom_kind_key_table()  "{{{1
  It should succeed with valid name "buffer"

  let custom_buffer_key_table = Call('s:custom_kind_key_table', 'buffer')
  Should custom_buffer_key_table ==# {}
  Should Ref('s:custom_kind_key_tables') ==# {'buffer': {}}
  let custom_buffer_key_table_2 = Call('s:custom_kind_key_table', 'buffer')
  Should custom_buffer_key_table is custom_buffer_key_table_2
  Should Ref('s:custom_kind_key_tables') ==# {'buffer': {}}

  It currently accept invalid name "!@#$%"

  let custom_xxxxx_key_table = Call('s:custom_kind_key_table', '!@#$%')
  Should custom_xxxxx_key_table ==# {}
  Should Ref('s:custom_kind_key_tables') ==# {'buffer': {}, '!@#$%': {}}
  let custom_xxxxx_key_table_2 = Call('s:custom_kind_key_table', '!@#$%')
  Should custom_xxxxx_key_table is custom_xxxxx_key_table_2
  Should Ref('s:custom_kind_key_tables') ==# {'buffer': {}, '!@#$%': {}}

  It should create different tables for different kinds

  Should custom_buffer_key_table isnot custom_xxxxx_key_table

  ResetContext
endfunction




function s:describe__s_default_kind_key_table()  "{{{1
  It should return {} for a kind which is not defined

  Should Call('s:default_kind_key_table', 'buffer') ==# {}

  It should return the default key table

  let kind_a = {
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer',
  \ }
  Should ku#define_kind(kind_a) == 1

  Should Call('s:default_kind_key_table', 'buffer') ==# {'c': 'close'}
  Should Call('s:default_kind_key_table', 'buffer') is kind_a.default_key_table

  " Reset side effect.
  ResetContext
endfunction




function s:describe__s_get_key()  "{{{1
  It requires that there is no character in the typeahead buffer

  let typeahead = ''
  while getchar(1) isnot 0
    let typeahead .= getchar()
  endwhile

  Should typeahead ==# ''

  It should return an ordinary key in the typeahead buffer

  call feedkeys('a')
  Should Call('s:get_key') ==# 'a'

  It should return a special key in the typeahead buffer

  call feedkeys("\<F1>")
  Should Call('s:get_key') ==# "\<F1>"

  It actually returns all content in the typeahead buffer

  call feedkeys('Sasara')
  Should Call('s:get_key') ==# 'Sasara'

  ResetContext
endfunction




function s:describe__s_list_key_tables()  "{{{1
  It requires the following initialization

  let kind_a = {
  \   'default_action_table': {'default': function('type')},
  \   'default_key_table': {'d': 'default'},
  \   'name': 'A',
  \ }
  let kind_b = {
  \   'default_action_table': {'default': function('get')},
  \   'default_key_table': {'d': 'default'},
  \   'name': 'B',
  \ }
  let kind_c = {
  \   'default_action_table': {'default': function('len')},
  \   'default_key_table': {'d': 'default'},
  \   'name': 'C',
  \ }
  Should ku#define_kind(kind_a) == 1
  Should ku#define_kind(kind_b) == 1
  Should ku#define_kind(kind_c) == 1

  It should return key tables for given kinds in proper order

  Should Call('s:list_key_tables', [kind_a, kind_b, kind_c])
  \ == [
  \    Call('s:custom_kind_key_table', kind_a.name),
  \    Call('s:default_kind_key_table', kind_a.name),
  \    Call('s:custom_kind_key_table', kind_b.name),
  \    Call('s:default_kind_key_table', kind_b.name),
  \    Call('s:custom_kind_key_table', kind_c.name),
  \    Call('s:default_kind_key_table', kind_c.name),
  \ ]

  " Reset side effect.
  ResetContext
endfunction




" __END__  "{{{1
" vim: filetype=vim foldmethod=marker
