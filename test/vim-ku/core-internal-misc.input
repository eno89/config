" Test: vim-ku core-internal-misc
runtime! plugin/ku.vim plugin/ku/**/*.vim
call vspec#hint({'scope': 'ku#_local_variables()', 'sid': 'ku#_sid_prefix()'})
function s:describe__ku_available_source_p()  "{{{1
  let F = function('function')
  let G = function('type')

  It should return false for non existing source

  Should ku#available_sources() == {}
  Should ku#available_source_names() == []
  Should ku#available_source_p('test') == 0
  Should ku#available_source_p('abc') == 0
  Should ku#available_source_p('NoSuchSource') == 0

  It should return true for an existing source

  Should ku#define_source({'gather_candidates': F, 'name': 'test'}) == 1
  Should ku#available_source_names() == ['test']
  Should ku#available_source_p('test') == 1
  Should ku#available_source_p('abc') == 0
  Should ku#available_source_p('NoSuchSource') == 0

  It should return true for an existing source which is overridden

  Should ku#define_source({'gather_candidates': G, 'name': 'test'}) == 1
  Should ku#available_source_names() == ['test']
  Should ku#available_source_p('test') == 1
  Should ku#available_source_p('abc') == 0
  Should ku#available_source_p('NoSuchSource') == 0

  It should return true for another existing source

  Should ku#define_source({'gather_candidates': F, 'name': 'abc'}) == 1
  Should ku#available_source_names() == ['abc', 'test']
  Should ku#available_source_p('test') == 1
  Should ku#available_source_p('abc') == 1
  Should ku#available_source_p('NoSuchSource') == 0

  " Reset side effect.
  ResetContext
endfunction




function s:describe__ku_available_source_names()  "{{{1
  let F = function('function')
  let G = function('type')

  It should return [] if there is no source

  Should ku#available_sources() == {}
  Should ku#available_source_names() == []

  It should return ['test'] if there is a source 'test'

  Should ku#define_source({'gather_candidates': F, 'name': 'test'}) == 1
  Should ku#available_source_names() == ['test']

  It should return ['test'] if source 'test' is overrdden

  Should ku#define_source({'gather_candidates': G, 'name': 'test'}) == 1
  Should ku#available_source_names() == ['test']

  It should return multiple names if there are multiple sources

  Should ku#define_source({'gather_candidates': F, 'name': 'abc'}) == 1
  Should ku#available_source_names() == ['abc', 'test']

  " Reset side effect.
  ResetContext
endfunction




function s:describe__ku_available_sources()  "{{{1
  let F = function('function')
  let G = function('type')

  It should return {} if there is no source

  Should ku#available_sources() == {}
  Should ku#available_sources() == Ref('s:available_sources')

  It should return {} after failed ku#define_source()

  Should ku#define_source({}) == 0
  Should ku#define_source({'gather_candidates': 0, 'name': 0}) == 0
  Should ku#define_source({'gather_candidates': 0, 'name': 'test'}) == 0
  Should ku#define_source({'gather_candidates': F, 'name': 0}) == 0
  Should sort(keys(ku#available_sources())) == []
  Should ku#available_sources() == Ref('s:available_sources')

  It should return some content after successful ku#define_source()

  Should ku#define_source({'gather_candidates': F, 'name': 'test'}) == 1
  Should sort(keys(ku#available_sources())) == ['test']
  Should ku#available_sources() == Ref('s:available_sources')

  It should return some content after overriding a source

  Should ku#define_source({'gather_candidates': G, 'name': 'test'}) == 1
  Should sort(keys(ku#available_sources())) == ['test']
  Should ku#available_sources() == Ref('s:available_sources')

  " Reset side effect.
  ResetContext
endfunction




function s:describe__s_initialize_ku_buffer__with_users_init_autocmd()  "{{{1
  augroup test
    autocmd FileType ku  echo '" autocmd FileType ku'
  augroup END

  call Call('s:initialize_ku_buffer')

  It should set basic optoins

  Should &l:bufhidden ==# 'hide'
  Should &l:buflisted == 0
  Should &l:buftype ==# 'nofile'
  Should &l:omnifunc ==# 'ku#omnifunc'
  Should &l:swapfile == 0
  Should bufname('') ==# Ref('s:KU_BUFFER_NAME')

  It should define several autocommands for the current buffer

  Should exists('#plugin-ku#BufLeave#<buffer>') == 1
  Should exists('#plugin-ku#CursorMovedI#<buffer>') == 1
  Should exists('#plugin-ku#InsertEnter#<buffer>') == 1
  Should exists('#plugin-ku#TabLeave#<buffer>') == 0
  Should exists('#plugin-ku#WinLeave#<buffer>') == 1

  It should define several named key mappings for the current buffer

  Should maparg('<BS>', 'i') != '' == 1
  Should maparg('<C-h>', 'i') != '' == 1
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'i') != '' == 1
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'n') != '' == 1
  Should maparg('<Plug>(ku-do-the-default-action)', 'i') != '' == 1
  Should maparg('<Plug>(ku-do-the-default-action)', 'n') != '' == 1
  Should maparg('<Plug>(ku-quit-session)', 'i') != '' == 1
  Should maparg('<Plug>(ku-quit-session)', 'n') != '' == 1

  It should not define any ui key mapping for the current buffer

  Should maparg('<C-c>', 'n') == ''

  It should affect only the current buffer when it is called

  noautocmd bwipeout!  " s:quit_session() is harmful for this test

  Should &l:bufhidden ==# ''
  Should &l:buflisted == 1
  Should &l:buftype ==# ''
  Should &l:omnifunc ==# ''
  Should &l:swapfile == 1
  Should bufname('') ==# ''

  Should exists('#plugin-ku#BufLeave#<buffer>') == 0
  Should exists('#plugin-ku#CursorMovedI#<buffer>') == 0
  Should exists('#plugin-ku#InsertEnter#<buffer>') == 0
  Should exists('#plugin-ku#TabLeave#<buffer>') == 0
  Should exists('#plugin-ku#WinLeave#<buffer>') == 0

  Should maparg('<BS>', 'i') == ''
  Should maparg('<C-h>', 'i') == ''
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'i') == ''
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'n') == ''
  Should maparg('<Plug>(ku-do-the-default-action)', 'i') == ''
  Should maparg('<Plug>(ku-do-the-default-action)', 'n') == ''
  Should maparg('<Plug>(ku-quit-session)', 'i') == ''
  Should maparg('<Plug>(ku-quit-session)', 'n') == ''

  Should maparg('<C-c>', 'n') == ''

  " Reset side effect.
  augroup test
    autocmd! FileType ku
  augroup END
endfunction




function s:describe__s_initialize_ku_buffer__with_users_init_ftplugin() "{{{1
  let b:did_ftplugin = 'ku'  " trick the core as if there is a ftplugin

  call Call('s:initialize_ku_buffer')

  It should set basic optoins

  Should &l:bufhidden ==# 'hide'
  Should &l:buflisted == 0
  Should &l:buftype ==# 'nofile'
  Should &l:omnifunc ==# 'ku#omnifunc'
  Should &l:swapfile == 0
  Should bufname('') ==# Ref('s:KU_BUFFER_NAME')

  It should define several autocommands for the current buffer

  Should exists('#plugin-ku#BufLeave#<buffer>') == 1
  Should exists('#plugin-ku#CursorMovedI#<buffer>') == 1
  Should exists('#plugin-ku#InsertEnter#<buffer>') == 1
  Should exists('#plugin-ku#TabLeave#<buffer>') == 0
  Should exists('#plugin-ku#WinLeave#<buffer>') == 1

  It should define several named key mappings for the current buffer

  Should maparg('<BS>', 'i') != '' == 1
  Should maparg('<C-h>', 'i') != '' == 1
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'i') != '' == 1
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'n') != '' == 1
  Should maparg('<Plug>(ku-do-the-default-action)', 'i') != '' == 1
  Should maparg('<Plug>(ku-do-the-default-action)', 'n') != '' == 1
  Should maparg('<Plug>(ku-quit-session)', 'i') != '' == 1
  Should maparg('<Plug>(ku-quit-session)', 'n') != '' == 1

  It should not define any ui key mapping for the current buffer

  Should maparg('<C-c>', 'n') == ''

  It should affect only the current buffer when it is called

  noautocmd bwipeout!  " s:quit_session() is harmful for this test

  Should &l:bufhidden ==# ''
  Should &l:buflisted == 1
  Should &l:buftype ==# ''
  Should &l:omnifunc ==# ''
  Should &l:swapfile == 1
  Should bufname('') ==# ''

  Should exists('#plugin-ku#BufLeave#<buffer>') == 0
  Should exists('#plugin-ku#CursorMovedI#<buffer>') == 0
  Should exists('#plugin-ku#InsertEnter#<buffer>') == 0
  Should exists('#plugin-ku#TabLeave#<buffer>') == 0
  Should exists('#plugin-ku#WinLeave#<buffer>') == 0

  Should maparg('<BS>', 'i') == ''
  Should maparg('<C-h>', 'i') == ''
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'i') == ''
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'n') == ''
  Should maparg('<Plug>(ku-do-the-default-action)', 'i') == ''
  Should maparg('<Plug>(ku-do-the-default-action)', 'n') == ''
  Should maparg('<Plug>(ku-quit-session)', 'i') == ''
  Should maparg('<Plug>(ku-quit-session)', 'n') == ''

  Should maparg('<C-c>', 'n') == ''

  " No side effect to reset.
endfunction




function s:describe__s_initialize_ku_buffer__without_users_settings()  "{{{1
  call Call('s:initialize_ku_buffer')

  It should set basic optoins

  Should &l:bufhidden ==# 'hide'
  Should &l:buflisted == 0
  Should &l:buftype ==# 'nofile'
  Should &l:omnifunc ==# 'ku#omnifunc'
  Should &l:swapfile == 0
  Should bufname('') ==# Ref('s:KU_BUFFER_NAME')

  It should define several autocommands for the current buffer

  Should exists('#plugin-ku#BufLeave#<buffer>') == 1
  Should exists('#plugin-ku#CursorMovedI#<buffer>') == 1
  Should exists('#plugin-ku#InsertEnter#<buffer>') == 1
  Should exists('#plugin-ku#TabLeave#<buffer>') == 0
  Should exists('#plugin-ku#WinLeave#<buffer>') == 1

  It should define several named key mappings for the current buffer

  Should maparg('<BS>', 'i') != '' == 1
  Should maparg('<C-h>', 'i') != '' == 1
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'i') != '' == 1
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'n') != '' == 1
  Should maparg('<Plug>(ku-do-the-default-action)', 'i') != '' == 1
  Should maparg('<Plug>(ku-do-the-default-action)', 'n') != '' == 1
  Should maparg('<Plug>(ku-quit-session)', 'i') != '' == 1
  Should maparg('<Plug>(ku-quit-session)', 'n') != '' == 1

  It should define several ui key mappings for the current buffer

  Should maparg('<C-c>', 'n') == '<Plug>(ku-quit-session)'

  It should affect only the current buffer when it is called

  noautocmd bwipeout!  " s:quit_session() is harmful for this test

  Should &l:bufhidden ==# ''
  Should &l:buflisted == 1
  Should &l:buftype ==# ''
  Should &l:omnifunc ==# ''
  Should &l:swapfile == 1
  Should bufname('') ==# ''

  Should exists('#plugin-ku#BufLeave#<buffer>') == 0
  Should exists('#plugin-ku#CursorMovedI#<buffer>') == 0
  Should exists('#plugin-ku#InsertEnter#<buffer>') == 0
  Should exists('#plugin-ku#TabLeave#<buffer>') == 0
  Should exists('#plugin-ku#WinLeave#<buffer>') == 0

  Should maparg('<BS>', 'i') == ''
  Should maparg('<C-h>', 'i') == ''
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'i') == ''
  Should maparg('<Plug>(ku-choose-and-do-an-action)', 'n') == ''
  Should maparg('<Plug>(ku-do-the-default-action)', 'i') == ''
  Should maparg('<Plug>(ku-do-the-default-action)', 'n') == ''
  Should maparg('<Plug>(ku-quit-session)', 'i') == ''
  Should maparg('<Plug>(ku-quit-session)', 'n') == ''

  Should maparg('<C-c>', 'n') == ''

  " No side effect to reset.
endfunction




function s:describe__s_ku_active_p()  "{{{1
  It should return false for the initial state

  Should Call('s:ku_active_p') == 0

  It should return true after starting a ku session

  Should ku#start() == 1
  Should nr2char(getchar(0)) == 'A'
  Should nr2char(getchar(0)) == ''

  Should Call('s:ku_active_p') == 1

  It should return false after quitting a ku session

  close

  Should Call('s:ku_active_p') == 0

  " Reset side effect.
  call ku#start()
  Should nr2char(getchar(0)) == 'A'
  Should nr2char(getchar(0)) == ''
  bwipeout!
endfunction




function s:describe__s_new_session()  "{{{1
  let F = function('function')
  let G = function('type')
  let original_completeopt = &completeopt
  let original_curwinnr = winnr()
  let original_winrestcmd = winrestcmd()

  Should ku#define_source({'gather_candidates': F, 'name': 'abc'}) == 1
  Should ku#define_source({'gather_candidates': G, 'name': 'test'}) == 1
  Should ku#available_source_p('abc') == 1
  Should ku#available_source_p('test') == 1

  It should return a valid object without source (A)

  let session_a = Call('s:new_session', [])
  Should has_key(session_a, 'id') == 1
  Should session_a.now_quitting_p == 0
  Should session_a.original_completeopt == original_completeopt
  Should session_a.original_curwinnr == original_curwinnr
  Should session_a.original_winrestcmd == original_winrestcmd
  Should session_a.sources == []

  It should return a valid objec without source (B)

  let session_b = Call('s:new_session', [])
  Should has_key(session_b, 'id') == 1
  Should session_b.now_quitting_p == 0
  Should session_b.original_completeopt == original_completeopt
  Should session_b.original_curwinnr == original_curwinnr
  Should session_b.original_winrestcmd == original_winrestcmd
  Should session_b.sources == []

  It should return sessions with different session ids

  Should session_b.id isnot session_a.id

  It should return a valid object with some sources

  let session = Call('s:new_session', ['test', 'abc'])
  Should has_key(session, 'id') == 1
  Should session.now_quitting_p == 0
  Should session.original_completeopt == original_completeopt
  Should session.original_curwinnr == original_curwinnr
  Should session.original_winrestcmd == original_winrestcmd
  Should session.sources == [
  \   ku#available_sources()['test'],
  \   ku#available_sources()['abc']
  \ ]

  " Reset side effect.
  ResetContext
endfunction




function s:describe__s_on_CursorMovedI()  "{{{1
  It is not implemented and currently return ''

  " FIXME: NIY
  Should Call('s:on_CursorMovedI') == ''
endfunction




function s:describe__s_on_InsertEnter()  "{{{1
  It is not implemented and currently return ''

  " FIXME: NIY
  Should Call('s:on_InsertEnter') == ''
endfunction




function s:describe__s_quit_session()  "{{{1
  topleft new
  botright new
  set completeopt=preview
  let bufnr = bufnr('')
  let winnr = winnr()
  let winrestcmd = winrestcmd()
  let completeopt = &completeopt

  Should ku#start() == 1
  Should nr2char(getchar(0)) == 'A'
  Should nr2char(getchar(0)) == ''

  Should bufnr('') != bufnr == 1
  Should winnr() != winnr == 1
  Should winrestcmd() != winrestcmd == 1
  Should &completeopt != completeopt == 1

  It should reset side effect by ku#start()

  Should Call('s:quit_session') == 1
  let session = Ref('s:session')
  Should bufnr('') == bufnr
  Should winnr() == winnr
  Should winrestcmd() == winrestcmd
  Should &completeopt == completeopt

  " NTY: recursively called s:quit_session() - but how to test it?

  " Reset side effect.
  call ku#start()
  Should nr2char(getchar(0)) == 'A'
  Should nr2char(getchar(0)) == ''
  bwipeout!
  only
endfunction




function s:describe__s_valid_key_p()  "{{{1
  It should return false for invalid argument

  Should Call('s:valid_key_p', {}, '8bit', 0) == 0

  It should return false if key doesn't exist

  Should Call('s:valid_key_p', {'8bit': 'rave'}, 0, 'string') == 0

  It should return true for valid values

  Should Call('s:valid_key_p', {'8bit': {}}, '8bit', 'dictionary') == 1
  Should Call('s:valid_key_p', {'8': function('len')}, '8', 'function') == 1
  Should Call('s:valid_key_p', {'8bit': []}, '8bit', 'list') == 1
  Should Call('s:valid_key_p', {'8bit': 3339}, '8bit', 'number') == 1
  Should Call('s:valid_key_p', {'8bit': 'rave'}, '8bit', 'string') == 1

  It should return true for list with valid values

  Should Call('s:valid_key_p', {'A': [1, 2, 3]}, 'A', 'list of numbers') == 1
  Should Call('s:valid_key_p', {'A': []}, 'A', 'list of functions') == 1
  Should Call('s:valid_key_p',
  \ {'A': [function('len')]},
  \ 'A',
  \ 'list of functions')
  \ == 1

  It should return false for list with invalid values

  Should Call('s:valid_key_p', {'A': [1, 2, 3]}, 'A', 'list of strings') == 0
  Should Call('s:valid_key_p', {'A': [1,'2',3]}, 'A', 'list of numbers') == 0
endfunction




" __END__  "{{{1
" vim: filetype=vim foldmethod=marker
