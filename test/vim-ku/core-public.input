" Test: vim-ku core-public
" Set up  "{{{1

let s:SID_PREFIX = ku#_sid_prefix()

function Call(function_name, ...)
  return call(substitute(a:function_name, '^s:', s:SID_PREFIX, ''), a:000)
endfunction


let s:VARS = ku#_local_variables()

function! Ref(variable_name)
  return s:VARS[a:variable_name]
endfunction

function! Set(variable_name, value)
  let s:VARS[a:variable_name] = a:value
endfunction


command! NewBuffer  bwipeout! | enew!




function s:test_ku_custom_actioin()  "{{{1
  Title "ku#custom_action()"

  " Initialize.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}

  call Set('available_kinds', {})
  Assert ku#define_kind({
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ }) ==> 1
  Assert Ref('available_kinds') ==> {
  \ 'file': {
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ },
  \ }

  " Normal case: Using s:custom_action_1()
  Assert ku#custom_action('file', 'ai', function('len')) ==> 0
  Assert ku#custom_action('file', 'ai', function('get')) ==> function('len')

  " Normal case: Using s:custom_action_2()
  Assert ku#custom_action('file', 'default', 'file', 'get') ==> 0
  Assert ku#custom_action('file', 'default', 'file', 'get') ==> function('get')

  " Strange case: Using s:custom_action_2() with many extra arguments
  Assert ku#custom_action('file', 'new', 'file', 'get', '') ==> 0
  Assert ku#custom_action('file', 'new', 'file', 'get', '') ==> function('get')

  " So the internal is:
  Assert Ref('custom_kind_action_tables') ==> {
  \ 'file': {
  \ 'ai': function('get'),
  \ 'default': function('get'),
  \ 'new': function('get'),
  \ },
  \ }
  Assert Ref('available_kinds') ==> {
  \ 'file': {
  \ 'default_action_table': {'get': function('get'), 'len': function('len')},
  \ 'default_key_table': {'g': 'get'},
  \ 'name': 'file',
  \ },
  \ }

  " Reset side effect.
  call Set('custom_kind_action_tables', {})
  Assert Ref('custom_kind_action_tables') ==> {}
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}
endfunction




function s:test_ku_custom_key()  "{{{1
  Title "ku#custom_key()"

  " Initialize.
  call Set('custom_kind_key_tables', {})
  Assert Ref('custom_kind_key_tables') ==> {}

  " Define a few key bindings for kind "buffer" - valid name.
  Assert ku#custom_key('buffer', '<', 'lt') ==> 0
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'lt'}
  Assert ku#custom_key('buffer', '>', 'gt') ==> 0
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'lt', '>': 'gt'}

  " Override a key bindings for kind "buffer".
  Assert ku#custom_key('buffer', '<', 'LT') ==> 'lt'
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'LT', '>': 'gt'}
  Assert ku#custom_key('buffer', '>', 'GT') ==> 'gt'
  Assert Call('s:custom_kind_key_table', 'buffer') ==> {'<': 'LT', '>': 'GT'}

  " Define a few key bindings for kind "!@#$%" - invalid name but not checked.
  Assert ku#custom_key('!@#$%', '(', 'lb') ==> 0
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'lb'}
  Assert ku#custom_key('!@#$%', ')', 'rb') ==> 0
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'lb', ')': 'rb'}

  " Override a key bindings for kind "!@#$%".
  Assert ku#custom_key('!@#$%', '(', 'LB') ==> 'lb'
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'LB', ')': 'rb'}
  Assert ku#custom_key('!@#$%', ')', 'RB') ==> 'rb'
  Assert Call('s:custom_kind_key_table', '!@#$%') ==> {'(': 'LB', ')': 'RB'}

  " So the result is:
  Assert Ref('custom_kind_key_tables') ==> {
  \ 'buffer': {'<': 'LT', '>': 'GT'},
  \ '!@#$%': {'(': 'LB', ')': 'RB'},
  \ }

  " Reset side effect.
  call Set('custom_kind_key_tables', {})
  Assert Ref('custom_kind_key_tables') ==> {}
endfunction




function s:test_ku_define_default_ui_key_mappings()  "{{{1
  Title "ku#define_default_ui_key_mappings()"

  NewBuffer

  " Initial state.
  nnoremap <buffer> <C-c>  QUIT-NORMAL
  inoremap <buffer> <C-c>  QUIT-INSERT
  Assert maparg('<C-c>', 'i') ==> 'QUIT-INSERT'
  Assert maparg('<C-c>', 'n') ==> 'QUIT-NORMAL'
  Assert maparg('<C-i>', 'i') ==> ''
  Assert maparg('<C-i>', 'n') ==> ''
  Assert maparg('<C-m>', 'i') ==> ''
  Assert maparg('<C-m>', 'n') ==> ''
  Assert maparg('<Enter>', 'i') ==> ''
  Assert maparg('<Enter>', 'n') ==> ''
  Assert maparg('<Return>', 'i') ==> ''
  Assert maparg('<Return>', 'n') ==> ''
  Assert maparg('<Tab>', 'i') ==> ''
  Assert maparg('<Tab>', 'n') ==> ''

  " Define - don't override.
  call ku#define_default_ui_key_mappings(0)
  Assert maparg('<C-c>', 'i') ==> 'QUIT-INSERT'
  Assert maparg('<C-c>', 'n') ==> 'QUIT-NORMAL'
  Assert maparg('<C-i>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-i>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-m>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<C-m>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Tab>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<Tab>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'

  " Define - may override.
  call ku#define_default_ui_key_mappings(1)
  Assert maparg('<C-c>', 'i') ==> '<Plug>(ku-quit-session)'
  Assert maparg('<C-c>', 'n') ==> '<Plug>(ku-quit-session)'
  Assert maparg('<C-i>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-i>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<C-m>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<C-m>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Enter>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'i') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Return>', 'n') ==> '<Plug>(ku-do-the-default-action)'
  Assert maparg('<Tab>', 'i') ==> '<Plug>(ku-choose-and-do-an-action)'
  Assert maparg('<Tab>', 'n') ==> '<Plug>(ku-choose-and-do-an-action)'
endfunction




function s:test_ku_define_kind()  "{{{1
  Title "ku#define_kind()"

  " Initialize
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}

  " Define a kind - error cases.
  Assert ku#define_kind({
  \ 'default_key_table': {},
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ }) ==> 0

  Assert ku#define_kind({
  \ 'default_action_table': 0,
  \ 'default_key_table': {},
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'default_key_table': 0,
  \ 'name': 'file',
  \ }) ==> 0
  Assert ku#define_kind({
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'name': 0,
  \ }) ==> 0

  Assert Ref('available_kinds') ==> {}

  " Define a few kinds - valid cases.
  Assert ku#define_kind({
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer',
  \ }) ==> 1
  Assert ku#define_kind({
  \ 'default_action_table': {'open': function('type')},
  \ 'default_key_table': {'o': 'open'},
  \ 'name': 'file',
  \ }) ==> 1

  Assert Ref('available_kinds') ==> {
  \ 'buffer': {
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer'
  \ },
  \ 'file': {
  \ 'default_action_table': {'open': function('type')},
  \ 'default_key_table': {'o': 'open'},
  \ 'name': 'file'
  \ },
  \ }

  " Override a kind.
  Assert ku#define_kind({
  \ 'default_action_table': {'despair': function('type')},
  \ 'default_key_table': {'d': 'despair'},
  \ 'name': 'file',
  \ }) ==> 1

  Assert Ref('available_kinds') ==> {
  \ 'buffer': {
  \ 'default_action_table': {'close': function('type')},
  \ 'default_key_table': {'c': 'close'},
  \ 'name': 'buffer'
  \ },
  \ 'file': {
  \ 'default_action_table': {'despair': function('type')},
  \ 'default_key_table': {'d': 'despair'},
  \ 'name': 'file'
  \ },
  \ }

  " Reset side effect.
  call Set('available_kinds', {})
  Assert Ref('available_kinds') ==> {}
endfunction




function s:test_ku_define_source()  "{{{1
  Title "ku#define_source()"

  let F = function('function')
  let G = function('type')
  let matchers = [function('ku#matcher#default#matches_p')]
  let sorters = [function('ku#sorter#default#sort')]
  call Set('available_sources', {})
  call Set('available_kinds', {})

  " Initial state.
  Assert Ref('available_sources') ==> {}
  Assert Ref('available_kinds') ==> {}

  " Define a source (bad cases).
  Assert ku#define_source({}) ==> 0
  Assert ku#define_source({'gather_candidates': 0, 'name': 0}) ==> 0
  Assert ku#define_source({'gather_candidates': 0, 'name': 'test'}) ==> 0
  Assert ku#define_source({'gather_candidates': F, 'name': 0}) ==> 0
  Assert Ref('available_sources') ==> {}
  Assert Ref('available_kinds') ==> {}

  " Define a source (ordinary case).
  Assert ku#define_source({'gather_candidates': F, 'name': 'test'}) ==> 1
  Assert Ref('available_sources')['test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'filters': [],
  \ 'gather_candidates': F,
  \ 'kinds': ['source/test'],
  \ 'matchers': matchers,
  \ 'name': 'test',
  \ 'sorters': sorters,
  \ }
  Assert Ref('available_kinds')['source/test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'name': 'source/test',
  \ }

  " Override an existing source.
  Assert ku#define_source({'gather_candidates': G, 'name': 'test'}) ==> 1
  Assert Ref('available_sources')['test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'filters': [],
  \ 'gather_candidates': G,
  \ 'kinds': ['source/test'],
  \ 'matchers': matchers,
  \ 'name': 'test',
  \ 'sorters': sorters,
  \ }
  Assert Ref('available_kinds')['source/test']
  \ ==> {
  \ 'default_action_table': {},
  \ 'default_key_table': {},
  \ 'name': 'source/test',
  \ }

  " With optional attributes.
  Assert ku#define_source({
  \ 'default_action_table': {'checkout': function('function')},
  \ 'default_key_table': {'/': 'checkout'},
  \ 'filters': [G],
  \ 'gather_candidates': F,
  \ 'kinds': ['git', 'file'],
  \ 'matchers': [G],
  \ 'name': 'test',
  \ 'sorters': [F]})
  \ ==> 1
  Assert Ref('available_sources')['test']
  \ ==> {
  \ 'default_action_table': {'checkout': function('function')},
  \ 'default_key_table': {'/': 'checkout'},
  \ 'filters': [G],
  \ 'gather_candidates': F,
  \ 'kinds': ['source/test', 'git', 'file'],
  \ 'matchers': [G],
  \ 'name': 'test',
  \ 'sorters': [F],
  \ }
  Assert Ref('available_kinds')['source/test']
  \ ==> {
  \ 'default_action_table': {'checkout': function('function')},
  \ 'default_key_table': {'/': 'checkout'},
  \ 'name': 'source/test',
  \ }

  " Reset side effect for further tests.
  call Set('available_sources', {})
  call Set('available_kinds', {})
endfunction




function s:test_ku_start()  "{{{1
  Title "ku#start()"

  " Initial state.
  NewBuffer
  let first_bufnr = bufnr('')

  Assert &l:buftype ==> ''
  Assert winnr('$') ==> 1
  Assert winnr() ==> 1

  " Case 1: The ku buffer is not created.
  call feedkeys('abc', 't')
  Assert ku#start() ==> 1
  let second_bufnr = bufnr('')

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> 'a'
  Assert nr2char(getchar(0)) ==> 'b'
  Assert nr2char(getchar(0)) ==> 'c'
  Assert nr2char(getchar(0)) ==> ''

  Assert &g:completeopt ==> 'menu,menuone'
  Assert &l:filetype ==> 'ku'
  Assert [line('.'), col('.')] ==> [2, 1]
  Assert bufnr('') != first_bufnr ==> 1
  Assert getline(1, line('$')) ==> ['', '>']
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 2: The ku buffer is already created.
  close
  Assert ku#start() ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') ==> second_bufnr
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 3: The ku buffer has been deleted.
  noautocmd bwipeout!  " :noautocmd to avoid calling event handlers.
  Assert ku#start() ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') != first_bufnr ==> 1
  Assert bufnr('') != second_bufnr ==> 1
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 4: With {sources}.
  close
  Assert ku#start() ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''
  Assert winnr() ==> 1
  Assert winnr('$') ==> 2

  " Case 5: With {sources} including invalid values.
  close
  Assert ku#start(['invalid']) ==> 0

  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') ==> first_bufnr
  Assert winnr('$') ==> 1
  Assert winnr() ==> 1

  " Case 6: With {initial-pattern}.
  Assert ku#start(0, 'def') ==> 1

  Assert nr2char(getchar(0)) ==> 'A'
  Assert nr2char(getchar(0)) ==> ''

  Assert bufnr('') != first_bufnr ==> 1
  Assert getline(1, line('$')) ==> ['', '>def']
  Assert winnr('$') ==> 2
  Assert winnr() ==> 1

  " Case 7: Calling ku#start() while the ku buffer is active.
  Assert ku#start() ==> 0

  Assert nr2char(getchar(0)) ==> ''

  " FIXME: NTY: If there is some text in the ku buffer.
  " FIXME: NTY: If there is no room to create a new window.

  " Reset side effect.
  noautocmd bwipeout!  " :noautocmd to avoid calling event handlers.
endfunction




Test  "{{{1

" __END__
" vim: filetype=vim foldmethod=marker
