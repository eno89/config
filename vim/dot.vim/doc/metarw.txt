*metarw.txt*	a framework to read/write a fake:path

Version 0.0.0
Copyright (C) 2008 kana <http://whileimautomaton.net/>
License: MIT license  {{{
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}}}

CONTENTS					*metarw-contents*

Introduction		|metarw-introduction|
Interface		|metarw-interface|
  Commands		  |metarw-commands|
  Functions		  |metarw-functions|
  Key Mappings		  |metarw-key-mappings|
  Content Browswer	  |metarw-content-browser|
Schemes			|metarw-schemes|
Terms			|metarw-terms|
Bugs			|metarw-bugs|
Changelog		|metarw-changelog|




==============================================================================
INTRODUCTION					*metarw-introduction*

metarw is a Vim plugin to provide a framework to read/write a file-like
argument of which name is written in URI-like notation such as
"git:master:src/ui.c".  metarw also provides content browser like |netrw|'s
one for some sorts of argumetns if they are given to :edit or other command.

Requirements:
- Vim 7.1 or later.




==============================================================================
INTERFACE					*metarw-interface*

------------------------------------------------------------------------------
COMMANDS					*metarw-commands*

:Edit[!] [++opt] [+cmd] [{file}]		*:Edit*
:New [++opt] [+cmd] [{file}]			*:New*
:Read [++opt] [{file}]				*:Read*
:Source [{file}]				*:Source*
:[range]Write[!] [{file}]			*:Write*
			Same as |:edit| and other commands, but the completion
			of their arguments is extended to also complete
			fakepathes.


------------------------------------------------------------------------------
FUNCTIONS					*metarw-functions*

						*metarw#complete()*
metarw#complete({arglead}, {cmdline}, {cursorpos})
			Function for |:command-complete| to complete also
			fakepathes.  Use as follows:
			"-complete=customlist,metarw#complete".


------------------------------------------------------------------------------
KEY MAPPINGS					*metarw-key-mappings*

The following key mappings are available for |metarw-content-browser|.  All of
them are buffer-local and defined in Normal mode:


<Plug>(metarw-open-here)			*<Plug>(metarw-open-here)*
<Plug>(metarw-open-split)			*<Plug>(metarw-open-split)*
<Plug>(metarw-open-vsplit)			*<Plug>(metarw-open-vsplit)*
			Open the item under the cursor in the current window
			or newly created window.  If there is no item under
			the cursor, nothing will be happened.

<Plug>(metarw-go-to-parent)			*<Plug>(metarw-go-to-parent)*
			Open the "parent" item in the current window.  The
			"parent" item is always the first item listed in
			a content browser.

					    *g:metarw_no_default_key_mappings*
The following key mappings will be also available unless
g:metarw_no_default_key_mappings is defined:

{lhs}			{rhs}
--------		-----------------------------
<Return>		<Plug>(metarw-open-here)
<C-m>			<Plug>(metarw-open-here)
o			<Plug>(metarw-open-split)
v			<Plug>(metarw-open-vsplit)
-			<Plug>(metarw-go-to-parent)


------------------------------------------------------------------------------
CONTENT BROWSER					*metarw-content-browser*

If some sorts of fakepaths (which depend on their schemes) are given to
|:edit|, |:new| or other commands, metarw will set up the newly created buffer
as a content browser like |newrw|'s one for the given fakepath.

In this content browser, |metarw-key-mappings| are available, and 'filetype'
of a content browser is set to "metarw".  Use this information for your own
customization.




==============================================================================
SCHEMES						*metarw-schemes*

To add your own scheme, write a Vim script and put it under a directory named
"autoload/metarw/" in 'runtimepath'.  Such script is called as a scheme
script.  The name of a scheme script must be "{scheme}.vim", where {scheme} is
the name of the scheme.

Scheme scripts must implements the following functions.  Most of works such as
hooking read/write events are automatically treated by metarw, so you don't
have to think about troublesome stuffs.

						*metarw#{scheme}#complete()*
metarw#{scheme}#complete({arglead}, {cmdline}, {cursorpos})
			Complete the names of fakepaths.  See
			|:command-completion-customlist| for the detail of
			arguments and returning values of this function.

metarw#{scheme}#read({fakepath}, {suffix})	*metarw#{scheme}#read()*
			Read the content of {fakepath}.
			This function returns:
			- a dictionary if it succeeds.
			- a string as an error message if it fails.

			If the name of the current buffer contains a suffix
			which is described in "buffer_name_suffix", {fakepath}
			is the name without the suffix and {suffix} is the
			suffix.  Otherwise, {fakepath} is the name itself and
			{suffix} is an empty string.

			If return value is a dictionary, it has following
			items:
			
			"items" (list) /optional/
				If this key exists, the current buffer will be
				set up as |metarw-content-browser|.
				Otherwise, it has to read the content of
				{fakepath} with |:read| or other commands.

				Each value is a dictionary which represents an
				item in {fakepath}.  The meanings of key-value
				pairs are:

				"label" (string) /required/
					Displayed as the label of the item.

				"fakepath" (string) /required/
					Used to open an item.

				And, the 0th item should be the "parent" one
				of {fakepath}.  This item is used for
				|<Plug>(metarw-go-to-parent)|.

			"buffer_name_suffix" (string) /optional/
				This value is used as the suffix of the name
				of a content browser buffer, for example,
				"buffer-name (suffix)".  If this value is not
				given, no such suffix will be appended, so
				the name will be same as {fakepath}.

			See also |metarw-content-browser|.

						*metarw#{scheme}#write()*
metarw#{scheme}#write({fakepath}, {suffix}, {line1}, {line2}, {append-p})
			Write or append the content of the current buffer from
			{line1} to {lin2} into {fakepath}.  If {append-p} is
			true, does appending instead of writing.

			Return 0 on success, or a string as an error message
			on failure.

			Don't reset 'modified' in this function.  It will be
			automatically treated by metarw.

			See also |metarw#{scheme}#read()| for the defailt of
			{fakepath} and {suffix}.




==============================================================================
TERMS						*metarw-terms*

Fakepath					*metarw-fakepath*
	Fakepathes are file-like arguments written in URI-like notation.
	For example, "git:master:src/ui.c" is a fakepath.

Scheme						*metarw-scheme*
	Scheme is the substring before the first ":" in the name of
	a fakepath.  For example, the scheme of "git:master:src/ui.c" is
	"git".

Scheme script					*metarw-scheme-script*
	Support script to enable to read/write fakepathes.  One scheme script
	supports just one scheme.




==============================================================================
BUGS						*metarw-bugs*

- There are many bugs around the world.




==============================================================================
CHANGELOG					*metarw-changelog*

0.0.0	2008-07-11T16:51:59+09:00
	- Initial version.




==============================================================================
vim:tw=78:ts=8:ft=help:norl:fdm=marker:
